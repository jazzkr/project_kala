
Blink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000012  00800100  00000f58  00000fec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f58  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000042  00800112  00800112  00000ffe  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ffe  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001030  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001b8  00000000  00000000  00001070  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008421  00000000  00000000  00001228  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000161b  00000000  00000000  00009649  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001810  00000000  00000000  0000ac64  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000580  00000000  00000000  0000c474  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000034eb  00000000  00000000  0000c9f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002ee6  00000000  00000000  0000fedf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000180  00000000  00000000  00012dc5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
   4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
   c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  2c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  40:	0c 94 49 04 	jmp	0x892	; 0x892 <__vector_16>
  44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  48:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  4c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
  64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
  68:	05 07       	cpc	r16, r21

0000006a <__ctors_end>:
  6a:	11 24       	eor	r1, r1
  6c:	1f be       	out	0x3f, r1	; 63
  6e:	cf ef       	ldi	r28, 0xFF	; 255
  70:	d8 e0       	ldi	r29, 0x08	; 8
  72:	de bf       	out	0x3e, r29	; 62
  74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	a0 e0       	ldi	r26, 0x00	; 0
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	e8 e5       	ldi	r30, 0x58	; 88
  7e:	ff e0       	ldi	r31, 0x0F	; 15
  80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
  82:	05 90       	lpm	r0, Z+
  84:	0d 92       	st	X+, r0
  86:	a2 31       	cpi	r26, 0x12	; 18
  88:	b1 07       	cpc	r27, r17
  8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
  8c:	21 e0       	ldi	r18, 0x01	; 1
  8e:	a2 e1       	ldi	r26, 0x12	; 18
  90:	b1 e0       	ldi	r27, 0x01	; 1
  92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
  94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
  96:	a4 35       	cpi	r26, 0x54	; 84
  98:	b2 07       	cpc	r27, r18
  9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	c5 e3       	ldi	r28, 0x35	; 53
  a0:	d0 e0       	ldi	r29, 0x00	; 0
  a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
  a4:	21 97       	sbiw	r28, 0x01	; 1
  a6:	fe 01       	movw	r30, r28
  a8:	0e 94 95 07 	call	0xf2a	; 0xf2a <__tablejump2__>
  ac:	c4 33       	cpi	r28, 0x34	; 52
  ae:	d1 07       	cpc	r29, r17
  b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
  b2:	0e 94 3a 04 	call	0x874	; 0x874 <main>
  b6:	0c 94 aa 07 	jmp	0xf54	; 0xf54 <_exit>

000000ba <__bad_interrupt>:
  ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <_ZN14CLEDController4sizeEv>:
              }

              return adj;
      #endif
    }
    virtual uint16_t getMaxRefreshRate() const { return 0; }
  be:	fc 01       	movw	r30, r24
  c0:	85 85       	ldd	r24, Z+13	; 0x0d
  c2:	96 85       	ldd	r25, Z+14	; 0x0e
  c4:	08 95       	ret

000000c6 <_ZN14CLEDController9clearLedsEi>:
  c6:	cf 93       	push	r28
  c8:	df 93       	push	r29
  ca:	00 d0       	rcall	.+0      	; 0xcc <_ZN14CLEDController9clearLedsEi+0x6>
  cc:	00 d0       	rcall	.+0      	; 0xce <_ZN14CLEDController9clearLedsEi+0x8>
  ce:	00 d0       	rcall	.+0      	; 0xd0 <_ZN14CLEDController9clearLedsEi+0xa>
  d0:	cd b7       	in	r28, 0x3d	; 61
  d2:	de b7       	in	r29, 0x3e	; 62
  d4:	ab 01       	movw	r20, r22
  d6:	1c 82       	std	Y+4, r1	; 0x04
  d8:	1d 82       	std	Y+5, r1	; 0x05
  da:	1e 82       	std	Y+6, r1	; 0x06
  dc:	dc 01       	movw	r26, r24
  de:	ed 91       	ld	r30, X+
  e0:	fc 91       	ld	r31, X
  e2:	01 90       	ld	r0, Z+
  e4:	f0 81       	ld	r31, Z
  e6:	e0 2d       	mov	r30, r0
  e8:	19 82       	std	Y+1, r1	; 0x01
  ea:	1a 82       	std	Y+2, r1	; 0x02
  ec:	1b 82       	std	Y+3, r1	; 0x03
  ee:	9e 01       	movw	r18, r28
  f0:	2f 5f       	subi	r18, 0xFF	; 255
  f2:	3f 4f       	sbci	r19, 0xFF	; 255
  f4:	be 01       	movw	r22, r28
  f6:	6c 5f       	subi	r22, 0xFC	; 252
  f8:	7f 4f       	sbci	r23, 0xFF	; 255
  fa:	09 95       	icall
  fc:	26 96       	adiw	r28, 0x06	; 6
  fe:	0f b6       	in	r0, 0x3f	; 63
 100:	f8 94       	cli
 102:	de bf       	out	0x3e, r29	; 62
 104:	0f be       	out	0x3f, r0	; 63
 106:	cd bf       	out	0x3d, r28	; 61
 108:	df 91       	pop	r29
 10a:	cf 91       	pop	r28
 10c:	08 95       	ret

0000010e <_ZNK19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE17getMaxRefreshRateEv>:
public:
	virtual void init() {
		FastPin<DATA_PIN>::setOutput();
	}

	virtual uint16_t getMaxRefreshRate() const { return 400; }
 10e:	80 e9       	ldi	r24, 0x90	; 144
 110:	91 e0       	ldi	r25, 0x01	; 1
 112:	08 95       	ret

00000114 <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE4initEv>:
template<uint8_t PIN, uint8_t _MASK, typename _PORT, typename _DDR, typename _PIN> class _AVRPIN {
public:
	typedef volatile uint8_t * port_ptr_t;
	typedef uint8_t port_t;

	inline static void setOutput() { _DDR::r() |= _MASK; }
 114:	53 9a       	sbi	0x0a, 3	; 10
 116:	08 95       	ret

00000118 <setup>:
		return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
	}

	template<template<uint8_t DATA_PIN> class CHIPSET, uint8_t DATA_PIN>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN> c;
 118:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <_ZGVZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c>
 11c:	81 11       	cpse	r24, r1
 11e:	45 c0       	rjmp	.+138    	; 0x1aa <setup+0x92>
	///@param scale the rgb scaling to apply to each led before writing it out
    virtual void show(const struct CRGB *data, int nLeds, CRGB scale) = 0;

public:
	/// create an led controller object, add it to the chain of controllers
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
 120:	10 92 1e 01 	sts	0x011E, r1	; 0x80011e <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x3>
 124:	10 92 1d 01 	sts	0x011D, r1	; 0x80011d <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x2>
    {
    }

    /// allow construction from a LEDColorCorrection enum
    inline CRGB( LEDColorCorrection colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 128:	8f ef       	ldi	r24, 0xFF	; 255
 12a:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x6>
 12e:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x7>
 132:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x8>

    }

    /// allow construction from a ColorTemperature enum
    inline CRGB( ColorTemperature colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 136:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x9>
 13a:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0xa>
 13e:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0xb>
 142:	81 e0       	ldi	r24, 0x01	; 1
 144:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0xc>
 148:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0xe>
 14c:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0xd>
        m_pNext = NULL;
 150:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x5>
 154:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x4>
        if(m_pHead==NULL) { m_pHead = this; }
 158:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <_ZN14CLEDController7m_pHeadE>
 15c:	90 91 46 01 	lds	r25, 0x0146	; 0x800146 <_ZN14CLEDController7m_pHeadE+0x1>
 160:	89 2b       	or	r24, r25
 162:	31 f4       	brne	.+12     	; 0x170 <setup+0x58>
 164:	8b e1       	ldi	r24, 0x1B	; 27
 166:	91 e0       	ldi	r25, 0x01	; 1
 168:	90 93 46 01 	sts	0x0146, r25	; 0x800146 <_ZN14CLEDController7m_pHeadE+0x1>
 16c:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <_ZN14CLEDController7m_pHeadE>
        if(m_pTail != NULL) { m_pTail->m_pNext = this; }
 170:	e0 91 43 01 	lds	r30, 0x0143	; 0x800143 <_ZN14CLEDController7m_pTailE>
 174:	f0 91 44 01 	lds	r31, 0x0144	; 0x800144 <_ZN14CLEDController7m_pTailE+0x1>
 178:	30 97       	sbiw	r30, 0x00	; 0
 17a:	21 f0       	breq	.+8      	; 0x184 <setup+0x6c>
 17c:	8b e1       	ldi	r24, 0x1B	; 27
 17e:	91 e0       	ldi	r25, 0x01	; 1
 180:	95 83       	std	Z+5, r25	; 0x05
 182:	84 83       	std	Z+4, r24	; 0x04
        m_pTail = this;
 184:	8b e1       	ldi	r24, 0x1B	; 27
 186:	91 e0       	ldi	r25, 0x01	; 1
 188:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <_ZN14CLEDController7m_pTailE+0x1>
 18c:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <_ZN14CLEDController7m_pTailE>
/// Class to ensure that a minimum amount of time has kicked since the last time run - and delay if not enough time has passed yet
/// this should make sure that chipsets that have
template<int WAIT> class CMinWait {
	uint16_t mLastMicros;
public:
	CMinWait() { mLastMicros = 0; }
 190:	10 92 2b 01 	sts	0x012B, r1	; 0x80012b <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x10>
 194:	10 92 2a 01 	sts	0x012A, r1	; 0x80012a <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0xf>
#ifdef HAS_PIXIE
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class PIXIE : public PixieController<DATA_PIN, RGB_ORDER> {};
#endif

#ifdef FASTLED_HAS_CLOCKLESS
template<uint8_t DATA_PIN> class NEOPIXEL : public WS2812Controller800Khz<DATA_PIN, GRB> {};
 198:	84 e0       	ldi	r24, 0x04	; 4
 19a:	91 e0       	ldi	r25, 0x01	; 1
 19c:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c+0x1>
 1a0:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <_ZZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c>
		return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
	}

	template<template<uint8_t DATA_PIN> class CHIPSET, uint8_t DATA_PIN>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN> c;
 1a4:	81 e0       	ldi	r24, 0x01	; 1
 1a6:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <_ZGVZN8CFastLED7addLedsI8NEOPIXELLh3EEER14CLEDControllerP4CRGBiiE1c>
		return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 1aa:	20 e0       	ldi	r18, 0x00	; 0
 1ac:	30 e0       	ldi	r19, 0x00	; 0
 1ae:	41 e0       	ldi	r20, 0x01	; 1
 1b0:	50 e0       	ldi	r21, 0x00	; 0
 1b2:	6c e2       	ldi	r22, 0x2C	; 44
 1b4:	71 e0       	ldi	r23, 0x01	; 1
 1b6:	8b e1       	ldi	r24, 0x1B	; 27
 1b8:	91 e0       	ldi	r25, 0x01	; 1
 1ba:	0c 94 c7 06 	jmp	0xd8e	; 0xd8e <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii>

000001be <loop>:
      // FastLED.addLeds<P9813, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
      // FastLED.addLeds<APA102, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
      // FastLED.addLeds<DOTSTAR, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
}

void loop() { 
 1be:	0f 93       	push	r16
 1c0:	1f 93       	push	r17
 1c2:	cf 93       	push	r28
 1c4:	df 93       	push	r29
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 1c6:	cc e2       	ldi	r28, 0x2C	; 44
 1c8:	d1 e0       	ldi	r29, 0x01	; 1
 1ca:	8f ef       	ldi	r24, 0xFF	; 255
 1cc:	88 83       	st	Y, r24
        g = (colorcode >>  8) & 0xFF;
 1ce:	19 82       	std	Y+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
 1d0:	1a 82       	std	Y+2, r1	; 0x02
	/// Update all our controllers with the current led colors, using the passed in brightness
	/// @param scale temporarily override the scale
	void show(uint8_t scale);

	/// Update all our controllers with the current led colors
	void show() { show(m_Scale); }
 1d2:	07 e4       	ldi	r16, 0x47	; 71
 1d4:	11 e0       	ldi	r17, 0x01	; 1
 1d6:	f8 01       	movw	r30, r16
 1d8:	60 81       	ld	r22, Z
 1da:	c8 01       	movw	r24, r16
 1dc:	0e 94 f7 05 	call	0xbee	; 0xbee <_ZN8CFastLED4showEh>
  // Turn the LED on, then pause
  leds[0] = CRGB::Red;
  FastLED.show();
  delay(500);
 1e0:	64 ef       	ldi	r22, 0xF4	; 244
 1e2:	71 e0       	ldi	r23, 0x01	; 1
 1e4:	80 e0       	ldi	r24, 0x00	; 0
 1e6:	90 e0       	ldi	r25, 0x00	; 0
 1e8:	0e 94 c4 04 	call	0x988	; 0x988 <delay>
    }

    /// allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 1ec:	18 82       	st	Y, r1
        g = (colorcode >>  8) & 0xFF;
 1ee:	19 82       	std	Y+1, r1	; 0x01
        b = (colorcode >>  0) & 0xFF;
 1f0:	1a 82       	std	Y+2, r1	; 0x02
 1f2:	f8 01       	movw	r30, r16
 1f4:	60 81       	ld	r22, Z
 1f6:	c8 01       	movw	r24, r16
 1f8:	0e 94 f7 05 	call	0xbee	; 0xbee <_ZN8CFastLED4showEh>
  // Now turn the LED off, then pause
  leds[0] = CRGB::Black;
  FastLED.show();
  delay(500);
 1fc:	64 ef       	ldi	r22, 0xF4	; 244
 1fe:	71 e0       	ldi	r23, 0x01	; 1
 200:	80 e0       	ldi	r24, 0x00	; 0
 202:	90 e0       	ldi	r25, 0x00	; 0
}
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	1f 91       	pop	r17
 20a:	0f 91       	pop	r16
  FastLED.show();
  delay(500);
  // Now turn the LED off, then pause
  leds[0] = CRGB::Black;
  FastLED.show();
  delay(500);
 20c:	0c 94 c4 04 	jmp	0x988	; 0x988 <delay>

00000210 <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE15showRGBInternalER15PixelControllerILS0_66ELi1ELm4294967295EE>:
#define DADVANCE 3
#define DUSE (0xFF - (DADVANCE-1))

	// This method is made static to force making register Y available to use for data on AVR - if the method is non-static, then
	// gcc will use register Y for the this pointer.
	static void /*__attribute__((optimize("O0")))*/  /*__attribute__ ((always_inline))*/  showRGBInternal(PixelController<RGB_ORDER> & pixels)  {
 210:	9f 92       	push	r9
 212:	af 92       	push	r10
 214:	bf 92       	push	r11
 216:	cf 92       	push	r12
 218:	df 92       	push	r13
 21a:	ef 92       	push	r14
 21c:	ff 92       	push	r15
 21e:	0f 93       	push	r16
 220:	1f 93       	push	r17
 222:	cf 93       	push	r28
 224:	df 93       	push	r29
 226:	fc 01       	movw	r30, r24
		uint8_t *data = (uint8_t*)pixels.mData;
 228:	c0 80       	ld	r12, Z
 22a:	d1 80       	ldd	r13, Z+1	; 0x01
		data_ptr_t port = FastPin<DATA_PIN>::port();
		data_t mask = FastPin<DATA_PIN>::mask();
		uint8_t scale_base = 0;

		// register uint8_t *end = data + nLeds;
		data_t hi = *port | mask;
 22c:	2b b1       	in	r18, 0x0b	; 11
 22e:	28 60       	ori	r18, 0x08	; 8
 230:	b2 2e       	mov	r11, r18
		data_t lo = *port & ~mask;
 232:	9b b1       	in	r25, 0x0b	; 11
 234:	97 7f       	andi	r25, 0xF7	; 247
		*port = lo;
 236:	9b b9       	out	0x0b, r25	; 11
                d[2] = e[2] - d[2];
        }

        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
 238:	62 85       	ldd	r22, Z+10	; 0x0a
 23a:	87 81       	ldd	r24, Z+7	; 0x07
 23c:	06 2f       	mov	r16, r22
 23e:	08 1b       	sub	r16, r24
 240:	80 2f       	mov	r24, r16
 242:	07 83       	std	Z+7, r16	; 0x07

		// Setup the pixel controller
		pixels.preStepFirstByteDithering();

		// pull the dithering/adjustment values out of the pixels object for direct asm access
		uint8_t advanceBy = pixels.advanceBy();
 244:	77 85       	ldd	r23, Z+15	; 0x0f
		uint16_t count = pixels.mLen;
 246:	a2 81       	ldd	r26, Z+2	; 0x02
 248:	b3 81       	ldd	r27, Z+3	; 0x03

		uint8_t s0 = pixels.mScale.raw[RO(0)];
 24a:	35 85       	ldd	r19, Z+13	; 0x0d
		uint8_t s1 = pixels.mScale.raw[RO(1)];
 24c:	44 85       	ldd	r20, Z+12	; 0x0c
		uint8_t s2 = pixels.mScale.raw[RO(2)];
 24e:	56 85       	ldd	r21, Z+14	; 0x0e
#if (FASTLED_SCALE8_FIXED==1)
		s0++; s1++; s2++;
 250:	99 24       	eor	r9, r9
 252:	93 94       	inc	r9
 254:	93 0e       	add	r9, r19
 256:	4f 5f       	subi	r20, 0xFF	; 255
 258:	5f 5f       	subi	r21, 0xFF	; 255
#endif
		uint8_t d0 = pixels.d[RO(0)];
		uint8_t d1 = pixels.d[RO(1)];
 25a:	f6 80       	ldd	r15, Z+6	; 0x06
		uint8_t d2 = pixels.d[RO(2)];
 25c:	e0 84       	ldd	r14, Z+8	; 0x08
		uint8_t e0 = pixels.e[RO(0)];
		uint8_t e1 = pixels.e[RO(1)];
 25e:	c1 85       	ldd	r28, Z+9	; 0x09
		uint8_t e2 = pixels.e[RO(2)];
 260:	d3 85       	ldd	r29, Z+11	; 0x0b

		uint8_t loopvar=0;

		// This has to be done in asm to keep gcc from messing up the asm code further down
		b0 = data[RO(0)];
 262:	f6 01       	movw	r30, r12
 264:	11 81       	ldd	r17, Z+1	; 0x01
		{
			LDSCL4(b0,O0) 	PRESCALEA2(d0)
 266:	a1 2c       	mov	r10, r1
 268:	0a 2d       	mov	r16, r10
 26a:	2a 2d       	mov	r18, r10
 26c:	3a 2d       	mov	r19, r10
 26e:	31 81       	ldd	r19, Z+1	; 0x01
 270:	11 27       	eor	r17, r17
 272:	88 94       	clc
 274:	31 11       	cpse	r19, r1
 276:	38 0f       	add	r19, r24
			PRESCALEB4(d0)	SCALE02(b0,0)
 278:	08 f4       	brcc	.+2      	; 0x27c <L_483>
 27a:	3f ef       	ldi	r19, 0xFF	; 255

0000027c <L_483>:
 27c:	81 95       	neg	r24
 27e:	88 94       	clc
 280:	90 fc       	sbrc	r9, 0
 282:	13 0f       	add	r17, r19
			RORSC04(b0,1) 	ROR1(b0) CLC1
 284:	17 95       	ror	r17
 286:	88 94       	clc
 288:	91 fc       	sbrc	r9, 1
 28a:	13 0f       	add	r17, r19
 28c:	17 95       	ror	r17
 28e:	88 94       	clc
			SCROR04(b0,2)		SCALE02(b0,3)
 290:	92 fc       	sbrc	r9, 2
 292:	13 0f       	add	r17, r19
 294:	17 95       	ror	r17
 296:	88 94       	clc
 298:	93 fc       	sbrc	r9, 3
 29a:	13 0f       	add	r17, r19
			RORSC04(b0,4) 	ROR1(b0) CLC1
 29c:	17 95       	ror	r17
 29e:	88 94       	clc
 2a0:	94 fc       	sbrc	r9, 4
 2a2:	13 0f       	add	r17, r19
 2a4:	17 95       	ror	r17
 2a6:	88 94       	clc
			SCROR04(b0,5) 	SCALE02(b0,6)
 2a8:	95 fc       	sbrc	r9, 5
 2aa:	13 0f       	add	r17, r19
 2ac:	17 95       	ror	r17
 2ae:	88 94       	clc
 2b0:	96 fc       	sbrc	r9, 6
 2b2:	13 0f       	add	r17, r19
			RORSC04(b0,7) 	ROR1(b0) CLC1
 2b4:	17 95       	ror	r17
 2b6:	88 94       	clc
 2b8:	97 fc       	sbrc	r9, 7
 2ba:	13 0f       	add	r17, r19
 2bc:	17 95       	ror	r17
 2be:	88 94       	clc
			MOV_ADDDE04(b1,b0,d0,e0)
 2c0:	03 2f       	mov	r16, r19
 2c2:	91 10       	cpse	r9, r1
 2c4:	01 2f       	mov	r16, r17
 2c6:	86 0f       	add	r24, r22
			MOV1(b0,b1)
 2c8:	10 2f       	mov	r17, r16

		{
			// while(--count)
			{
				// Loop beginning
				DNOP;
 2ca:	00 2c       	mov	r0, r0
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
 2cc:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <L_483+0x54>
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
 2d0:	17 ff       	sbrs	r17, 7
 2d2:	9b b9       	out	0x0b, r25	; 11
 2d4:	30 81       	ld	r19, Z
 2d6:	00 27       	eor	r16, r16
 2d8:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 2da:	00 c0       	rjmp	.+0      	; 0x2dc <L_483+0x60>
 2dc:	00 c0       	rjmp	.+0      	; 0x2de <L_483+0x62>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 2de:	00 2c       	mov	r0, r0
				// out.  When doing byte 1, we're doing the above for byte 2.  When we're doing byte 2,
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
 2e0:	9b b9       	out	0x0b, r25	; 11
 2e2:	31 11       	cpse	r19, r1
 2e4:	3f 0d       	add	r19, r15
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 2e6:	00 c0       	rjmp	.+0      	; 0x2e8 <L_483+0x6c>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 2e8:	00 2c       	mov	r0, r0
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
 2ea:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 2ec:	00 c0       	rjmp	.+0      	; 0x2ee <L_483+0x72>
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
 2ee:	16 ff       	sbrs	r17, 6
 2f0:	9b b9       	out	0x0b, r25	; 11
 2f2:	08 f4       	brcc	.+2      	; 0x2f6 <L_1016>
 2f4:	3f ef       	ldi	r19, 0xFF	; 255

000002f6 <L_1016>:
 2f6:	f1 94       	neg	r15
 2f8:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 2fa:	00 c0       	rjmp	.+0      	; 0x2fc <L_1016+0x6>
 2fc:	00 c0       	rjmp	.+0      	; 0x2fe <L_1016+0x8>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 2fe:	00 2c       	mov	r0, r0
				// we're cycling back around and doing the above for byte 0.

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
 300:	9b b9       	out	0x0b, r25	; 11
 302:	40 fd       	sbrc	r20, 0
 304:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 306:	00 c0       	rjmp	.+0      	; 0x308 <L_1016+0x12>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 308:	00 2c       	mov	r0, r0

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
 30a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 30c:	00 c0       	rjmp	.+0      	; 0x30e <L_1016+0x18>

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
 30e:	15 ff       	sbrs	r17, 5
 310:	9b b9       	out	0x0b, r25	; 11
 312:	07 95       	ror	r16
 314:	88 94       	clc
 316:	41 fd       	sbrc	r20, 1
 318:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 31a:	00 c0       	rjmp	.+0      	; 0x31c <L_1016+0x26>
 31c:	00 c0       	rjmp	.+0      	; 0x31e <L_1016+0x28>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 31e:	00 2c       	mov	r0, r0

				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
 320:	9b b9       	out	0x0b, r25	; 11
 322:	07 95       	ror	r16
 324:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 326:	00 c0       	rjmp	.+0      	; 0x328 <L_1016+0x32>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 328:	00 2c       	mov	r0, r0
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
 32a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 32c:	00 c0       	rjmp	.+0      	; 0x32e <L_1016+0x38>
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
 32e:	14 ff       	sbrs	r17, 4
 330:	9b b9       	out	0x0b, r25	; 11
 332:	42 fd       	sbrc	r20, 2
 334:	03 0f       	add	r16, r19
 336:	07 95       	ror	r16
 338:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 33a:	00 c0       	rjmp	.+0      	; 0x33c <L_1016+0x46>
 33c:	00 c0       	rjmp	.+0      	; 0x33e <L_1016+0x48>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 33e:	00 2c       	mov	r0, r0
				// Inline scaling - RGB ordering
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
 340:	9b b9       	out	0x0b, r25	; 11
 342:	43 fd       	sbrc	r20, 3
 344:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 346:	00 c0       	rjmp	.+0      	; 0x348 <L_1016+0x52>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 348:	00 2c       	mov	r0, r0
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 34a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 34c:	00 c0       	rjmp	.+0      	; 0x34e <L_1016+0x58>
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 34e:	13 ff       	sbrs	r17, 3
 350:	9b b9       	out	0x0b, r25	; 11
 352:	07 95       	ror	r16
 354:	88 94       	clc
 356:	44 fd       	sbrc	r20, 4
 358:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 35a:	00 c0       	rjmp	.+0      	; 0x35c <L_1016+0x66>
 35c:	00 c0       	rjmp	.+0      	; 0x35e <L_1016+0x68>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 35e:	00 2c       	mov	r0, r0
				// DNOP
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 360:	9b b9       	out	0x0b, r25	; 11
 362:	07 95       	ror	r16
 364:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 366:	00 c0       	rjmp	.+0      	; 0x368 <L_1016+0x72>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 368:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
 36a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 36c:	00 c0       	rjmp	.+0      	; 0x36e <L_1016+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
 36e:	12 ff       	sbrs	r17, 2
 370:	9b b9       	out	0x0b, r25	; 11
 372:	45 fd       	sbrc	r20, 5
 374:	03 0f       	add	r16, r19
 376:	07 95       	ror	r16
 378:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 37a:	00 c0       	rjmp	.+0      	; 0x37c <L_1016+0x86>
 37c:	00 c0       	rjmp	.+0      	; 0x37e <L_1016+0x88>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 37e:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O1) 	D2(4)	LO1	PRESCALEA2(d1)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
 380:	9b b9       	out	0x0b, r25	; 11
 382:	46 fd       	sbrc	r20, 6
 384:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 386:	00 c0       	rjmp	.+0      	; 0x388 <L_1016+0x92>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 388:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 38a:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 38c:	00 c0       	rjmp	.+0      	; 0x38e <L_1016+0x98>
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 38e:	11 ff       	sbrs	r17, 1
 390:	9b b9       	out	0x0b, r25	; 11
 392:	07 95       	ror	r16
 394:	88 94       	clc
 396:	47 fd       	sbrc	r20, 7
 398:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 39a:	00 c0       	rjmp	.+0      	; 0x39c <L_1016+0xa6>
 39c:	00 c0       	rjmp	.+0      	; 0x39e <L_1016+0xa8>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 39e:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d1)	D2(4)	LO1	SCALE12(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 3a0:	9b b9       	out	0x0b, r25	; 11
 3a2:	07 95       	ror	r16
 3a4:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3a6:	00 c0       	rjmp	.+0      	; 0x3a8 <L_1016+0xb2>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 3a8:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
 3aa:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3ac:	00 c0       	rjmp	.+0      	; 0x3ae <L_1016+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC14(b1,1) 	D2(4)	LO1 RORCLC2(b1)		D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR14(b1,2)		D2(4)	LO1 SCALE12(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC14(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR14(b1,5) 	D2(4)	LO1 SCALE12(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC14(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
 3ae:	10 ff       	sbrs	r17, 0
 3b0:	9b b9       	out	0x0b, r25	; 11
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)
 3b2:	13 2f       	mov	r17, r19
 3b4:	41 11       	cpse	r20, r1
 3b6:	10 2f       	mov	r17, r16
 3b8:	fc 0e       	add	r15, r28
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3ba:	00 c0       	rjmp	.+0      	; 0x3bc <L_1016+0xc6>
 3bc:	00 c0       	rjmp	.+0      	; 0x3be <L_1016+0xc8>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 3be:	00 2c       	mov	r0, r0
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)
 3c0:	9b b9       	out	0x0b, r25	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3c2:	00 c0       	rjmp	.+0      	; 0x3c4 <L_1016+0xce>
 3c4:	00 c0       	rjmp	.+0      	; 0x3c6 <L_1016+0xd0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 3c6:	00 2c       	mov	r0, r0
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
 3c8:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3ca:	00 c0       	rjmp	.+0      	; 0x3cc <L_1016+0xd6>
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
 3cc:	17 ff       	sbrs	r17, 7
 3ce:	9b b9       	out	0x0b, r25	; 11
 3d0:	32 81       	ldd	r19, Z+2	; 0x02
 3d2:	00 27       	eor	r16, r16
 3d4:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <L_1016+0xe2>
 3d8:	00 c0       	rjmp	.+0      	; 0x3da <L_1016+0xe4>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 3da:	00 2c       	mov	r0, r0
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
 3dc:	9b b9       	out	0x0b, r25	; 11
 3de:	31 11       	cpse	r19, r1
 3e0:	3e 0d       	add	r19, r14
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3e2:	00 c0       	rjmp	.+0      	; 0x3e4 <L_1016+0xee>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 3e4:	00 2c       	mov	r0, r0
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
 3e6:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3e8:	00 c0       	rjmp	.+0      	; 0x3ea <L_1016+0xf4>
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
 3ea:	16 ff       	sbrs	r17, 6
 3ec:	9b b9       	out	0x0b, r25	; 11
 3ee:	08 f4       	brcc	.+2      	; 0x3f2 <L_2234>
 3f0:	3f ef       	ldi	r19, 0xFF	; 255

000003f2 <L_2234>:
 3f2:	e7 0f       	add	r30, r23
 3f4:	f1 1d       	adc	r31, r1
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 3f6:	00 c0       	rjmp	.+0      	; 0x3f8 <L_2234+0x6>
 3f8:	00 c0       	rjmp	.+0      	; 0x3fa <L_2234+0x8>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 3fa:	00 2c       	mov	r0, r0
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
 3fc:	9b b9       	out	0x0b, r25	; 11
 3fe:	50 fd       	sbrc	r21, 0
 400:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 402:	00 c0       	rjmp	.+0      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 404:	00 2c       	mov	r0, r0
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 406:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 408:	00 c0       	rjmp	.+0      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 40a:	15 ff       	sbrs	r17, 5
 40c:	9b b9       	out	0x0b, r25	; 11
 40e:	07 95       	ror	r16
 410:	88 94       	clc
 412:	51 fd       	sbrc	r21, 1
 414:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 416:	00 c0       	rjmp	.+0      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 418:	00 c0       	rjmp	.+0      	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 41a:	00 2c       	mov	r0, r0
				}
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 41c:	9b b9       	out	0x0b, r25	; 11
 41e:	07 95       	ror	r16
 420:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 422:	00 c0       	rjmp	.+0      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 424:	00 2c       	mov	r0, r0
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
 426:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 428:	00 c0       	rjmp	.+0      	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
 42a:	14 ff       	sbrs	r17, 4
 42c:	9b b9       	out	0x0b, r25	; 11
 42e:	52 fd       	sbrc	r21, 2
 430:	03 0f       	add	r16, r19
 432:	07 95       	ror	r16
 434:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 436:	00 c0       	rjmp	.+0      	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
 438:	00 c0       	rjmp	.+0      	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 43a:	00 2c       	mov	r0, r0
				MOV_ADDDE14(b0,b1,d1,e1) D2(4) LO1 D3(0)

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
 43c:	9b b9       	out	0x0b, r25	; 11
 43e:	53 fd       	sbrc	r21, 3
 440:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 442:	00 c0       	rjmp	.+0      	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 444:	00 2c       	mov	r0, r0

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 446:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 448:	00 c0       	rjmp	.+0      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 44a:	13 ff       	sbrs	r17, 3
 44c:	9b b9       	out	0x0b, r25	; 11
 44e:	07 95       	ror	r16
 450:	88 94       	clc
 452:	54 fd       	sbrc	r21, 4
 454:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 456:	00 c0       	rjmp	.+0      	; 0x458 <__LOCK_REGION_LENGTH__+0x58>
 458:	00 c0       	rjmp	.+0      	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 45a:	00 2c       	mov	r0, r0

				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 45c:	9b b9       	out	0x0b, r25	; 11
 45e:	07 95       	ror	r16
 460:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 462:	00 c0       	rjmp	.+0      	; 0x464 <__LOCK_REGION_LENGTH__+0x64>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 464:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
 466:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 468:	00 c0       	rjmp	.+0      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
 46a:	12 ff       	sbrs	r17, 2
 46c:	9b b9       	out	0x0b, r25	; 11
 46e:	55 fd       	sbrc	r21, 5
 470:	03 0f       	add	r16, r19
 472:	07 95       	ror	r16
 474:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 476:	00 c0       	rjmp	.+0      	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
 478:	00 c0       	rjmp	.+0      	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 47a:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O2) 	D2(4)	LO1	PRESCALEA2(d2)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
 47c:	9b b9       	out	0x0b, r25	; 11
 47e:	56 fd       	sbrc	r21, 6
 480:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 482:	00 c0       	rjmp	.+0      	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 484:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 486:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 488:	00 c0       	rjmp	.+0      	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 48a:	11 ff       	sbrs	r17, 1
 48c:	9b b9       	out	0x0b, r25	; 11
 48e:	07 95       	ror	r16
 490:	88 94       	clc
 492:	57 fd       	sbrc	r21, 7
 494:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 496:	00 c0       	rjmp	.+0      	; 0x498 <__LOCK_REGION_LENGTH__+0x98>
 498:	00 c0       	rjmp	.+0      	; 0x49a <__LOCK_REGION_LENGTH__+0x9a>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 49a:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PSBIDATA4(d2)		D2(4)	LO1	SCALE22(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 49c:	9b b9       	out	0x0b, r25	; 11
 49e:	07 95       	ror	r16
 4a0:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <__LOCK_REGION_LENGTH__+0xa4>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 4a4:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
 4a6:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4a8:	00 c0       	rjmp	.+0      	; 0x4aa <__LOCK_REGION_LENGTH__+0xaa>
				HI1 D1(1) QLO2(b0, 5) RORSC24(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR24(b1,2)		D2(4)	LO1 SCALE22(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC24(b1,4) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR24(b1,5) 	D2(4)	LO1 SCALE22(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC24(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
 4aa:	10 ff       	sbrs	r17, 0
 4ac:	9b b9       	out	0x0b, r25	; 11
				}

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
 4ae:	13 2f       	mov	r17, r19
 4b0:	51 11       	cpse	r21, r1
 4b2:	10 2f       	mov	r17, r16
 4b4:	e1 94       	neg	r14
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4b6:	00 c0       	rjmp	.+0      	; 0x4b8 <__LOCK_REGION_LENGTH__+0xb8>
 4b8:	00 c0       	rjmp	.+0      	; 0x4ba <__LOCK_REGION_LENGTH__+0xba>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 4ba:	00 2c       	mov	r0, r0
				}

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
 4bc:	9b b9       	out	0x0b, r25	; 11
 4be:	ed 0e       	add	r14, r29
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4c0:	00 c0       	rjmp	.+0      	; 0x4c2 <__LOCK_REGION_LENGTH__+0xc2>
 4c2:	00 c0       	rjmp	.+0      	; 0x4c4 <__LOCK_REGION_LENGTH__+0xc4>

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
 4c4:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4c6:	00 c0       	rjmp	.+0      	; 0x4c8 <__LOCK_REGION_LENGTH__+0xc8>

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
 4c8:	17 ff       	sbrs	r17, 7
 4ca:	9b b9       	out	0x0b, r25	; 11
 4cc:	31 81       	ldd	r19, Z+1	; 0x01
 4ce:	00 27       	eor	r16, r16
 4d0:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4d2:	00 c0       	rjmp	.+0      	; 0x4d4 <__LOCK_REGION_LENGTH__+0xd4>
 4d4:	00 c0       	rjmp	.+0      	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 4d6:	00 2c       	mov	r0, r0

				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
 4d8:	9b b9       	out	0x0b, r25	; 11
 4da:	31 11       	cpse	r19, r1
 4dc:	38 0f       	add	r19, r24
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4de:	00 c0       	rjmp	.+0      	; 0x4e0 <__LOCK_REGION_LENGTH__+0xe0>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 4e0:	00 2c       	mov	r0, r0
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
 4e2:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4e4:	00 c0       	rjmp	.+0      	; 0x4e6 <__LOCK_REGION_LENGTH__+0xe6>
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
 4e6:	16 ff       	sbrs	r17, 6
 4e8:	9b b9       	out	0x0b, r25	; 11
 4ea:	08 f4       	brcc	.+2      	; 0x4ee <L_3458>
 4ec:	3f ef       	ldi	r19, 0xFF	; 255

000004ee <L_3458>:
 4ee:	81 95       	neg	r24
 4f0:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4f2:	00 c0       	rjmp	.+0      	; 0x4f4 <L_3458+0x6>
 4f4:	00 c0       	rjmp	.+0      	; 0x4f6 <L_3458+0x8>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 4f6:	00 2c       	mov	r0, r0
				// Because Prescale on the middle byte also increments the data counter,
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
 4f8:	9b b9       	out	0x0b, r25	; 11
 4fa:	90 fc       	sbrc	r9, 0
 4fc:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 4fe:	00 c0       	rjmp	.+0      	; 0x500 <L_3458+0x12>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 500:	00 2c       	mov	r0, r0
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 502:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 504:	00 c0       	rjmp	.+0      	; 0x506 <L_3458+0x18>
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 506:	15 ff       	sbrs	r17, 5
 508:	9b b9       	out	0x0b, r25	; 11
 50a:	07 95       	ror	r16
 50c:	88 94       	clc
 50e:	91 fc       	sbrc	r9, 1
 510:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 512:	00 c0       	rjmp	.+0      	; 0x514 <L_3458+0x26>
 514:	00 c0       	rjmp	.+0      	; 0x516 <L_3458+0x28>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 516:	00 2c       	mov	r0, r0
				// we have to do both halves of updating d2 here - negating it (in the
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 518:	9b b9       	out	0x0b, r25	; 11
 51a:	07 95       	ror	r16
 51c:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 51e:	00 c0       	rjmp	.+0      	; 0x520 <L_3458+0x32>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 520:	00 2c       	mov	r0, r0
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
 522:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 524:	00 c0       	rjmp	.+0      	; 0x526 <L_3458+0x38>
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
 526:	14 ff       	sbrs	r17, 4
 528:	9b b9       	out	0x0b, r25	; 11
 52a:	92 fc       	sbrc	r9, 2
 52c:	03 0f       	add	r16, r19
 52e:	07 95       	ror	r16
 530:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 532:	00 c0       	rjmp	.+0      	; 0x534 <L_3458+0x46>
 534:	00 c0       	rjmp	.+0      	; 0x536 <L_3458+0x48>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 536:	00 2c       	mov	r0, r0
				// MOV_NEGD24 macro) and then adding E back into it
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
 538:	9b b9       	out	0x0b, r25	; 11
 53a:	93 fc       	sbrc	r9, 3
 53c:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 53e:	00 c0       	rjmp	.+0      	; 0x540 <L_3458+0x52>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 540:	00 2c       	mov	r0, r0
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
 542:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 544:	00 c0       	rjmp	.+0      	; 0x546 <L_3458+0x58>
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
 546:	13 ff       	sbrs	r17, 3
 548:	9b b9       	out	0x0b, r25	; 11
 54a:	07 95       	ror	r16
 54c:	88 94       	clc
 54e:	94 fc       	sbrc	r9, 4
 550:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 552:	00 c0       	rjmp	.+0      	; 0x554 <L_3458+0x66>
 554:	00 c0       	rjmp	.+0      	; 0x556 <L_3458+0x68>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 556:	00 2c       	mov	r0, r0
				MOV_NEGD24(b0,b1,d2) D2(4) LO1 ADDDE1(d2,e2) D3(1)
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
 558:	9b b9       	out	0x0b, r25	; 11
 55a:	07 95       	ror	r16
 55c:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 55e:	00 c0       	rjmp	.+0      	; 0x560 <L_3458+0x72>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 560:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
 562:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 564:	00 c0       	rjmp	.+0      	; 0x566 <L_3458+0x78>
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
 566:	12 ff       	sbrs	r17, 2
 568:	9b b9       	out	0x0b, r25	; 11
 56a:	95 fc       	sbrc	r9, 5
 56c:	03 0f       	add	r16, r19
 56e:	07 95       	ror	r16
 570:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 572:	00 c0       	rjmp	.+0      	; 0x574 <L_3458+0x86>
 574:	00 c0       	rjmp	.+0      	; 0x576 <L_3458+0x88>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 576:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 7) LDSCL4(b1,O0) 	D2(4)	LO1	PRESCALEA2(d0)	D3(2)
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
 578:	9b b9       	out	0x0b, r25	; 11
 57a:	96 fc       	sbrc	r9, 6
 57c:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 57e:	00 c0       	rjmp	.+0      	; 0x580 <L_3458+0x92>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 580:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 582:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 584:	00 c0       	rjmp	.+0      	; 0x586 <L_3458+0x98>
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 586:	11 ff       	sbrs	r17, 1
 588:	9b b9       	out	0x0b, r25	; 11
 58a:	07 95       	ror	r16
 58c:	88 94       	clc
 58e:	97 fc       	sbrc	r9, 7
 590:	03 0f       	add	r16, r19
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 592:	00 c0       	rjmp	.+0      	; 0x594 <L_3458+0xa6>
 594:	00 c0       	rjmp	.+0      	; 0x596 <L_3458+0xa8>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 596:	00 2c       	mov	r0, r0
				HI1	D1(1) QLO2(b0, 6) PRESCALEB4(d0)	D2(4)	LO1	SCALE02(b1,0)	D3(2)
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
 598:	9b b9       	out	0x0b, r25	; 11
 59a:	07 95       	ror	r16
 59c:	88 94       	clc
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 59e:	00 c0       	rjmp	.+0      	; 0x5a0 <L_3458+0xb2>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 5a0:	00 2c       	mov	r0, r0
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
 5a2:	bb b8       	out	0x0b, r11	; 11
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 5a4:	00 c0       	rjmp	.+0      	; 0x5a6 <L_3458+0xb8>
				HI1 D1(1) QLO2(b0, 5) RORSC04(b1,1) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 4) SCROR04(b1,2)		D2(4)	LO1 SCALE02(b1,3)	D3(2)
				HI1 D1(1) QLO2(b0, 3) RORSC04(b1,4) 	D2(4)	LO1 RORCLC2(b1)  	D3(2)
				HI1 D1(1) QLO2(b0, 2) SCROR04(b1,5) 	D2(4)	LO1 SCALE02(b1,6)	D3(2)
				HI1 D1(1) QLO2(b0, 1) RORSC04(b1,7) 	D2(4)	LO1 RORCLC2(b1) 	D3(2)
				HI1 D1(1) QLO2(b0, 0)
 5a6:	10 ff       	sbrs	r17, 0
 5a8:	9b b9       	out	0x0b, r25	; 11
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE04(b0,b1,d0,e0) D2(4) LO1 D3(5)
 5aa:	13 2f       	mov	r17, r19
 5ac:	91 10       	cpse	r9, r1
 5ae:	10 2f       	mov	r17, r16
 5b0:	86 0f       	add	r24, r22
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
template<> __attribute__((always_inline)) inline void _dc< 2>(register uint8_t & ) {asm __volatile__("rjmp .+0":::);}
 5b2:	00 c0       	rjmp	.+0      	; 0x5b4 <L_3458+0xc6>
 5b4:	00 c0       	rjmp	.+0      	; 0x5b6 <L_3458+0xc8>
template<> __attribute__((always_inline)) inline void _dc<-4>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-3>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-2>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc<-1>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 0>(register uint8_t & ) {}
template<> __attribute__((always_inline)) inline void _dc< 1>(register uint8_t & ) {asm __volatile__("mov r0,r0":::);}
 5b6:	00 2c       	mov	r0, r0
					case 4: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 3: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 2: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
					case 1: D2(0) LO1 D3(0) HI1 D1(1) QLO2(b0,0)
				}
				MOV_ADDDE04(b0,b1,d0,e0) D2(4) LO1 D3(5)
 5b8:	9b b9       	out	0x0b, r25	; 11
				ENDLOOP5
 5ba:	11 97       	sbiw	r26, 0x01	; 1
 5bc:	09 f0       	breq	.+2      	; 0x5c0 <L_4438>
 5be:	86 ce       	rjmp	.-756    	; 0x2cc <L_483+0x50>

000005c0 <L_4438>:

		#if (FASTLED_ALLOW_INTERRUPTS == 1)
		// stop using the clock juggler
		TCCR0A &= ~0x30;
		#endif
	}
 5c0:	df 91       	pop	r29
 5c2:	cf 91       	pop	r28
 5c4:	1f 91       	pop	r17
 5c6:	0f 91       	pop	r16
 5c8:	ff 90       	pop	r15
 5ca:	ef 90       	pop	r14
 5cc:	df 90       	pop	r13
 5ce:	cf 90       	pop	r12
 5d0:	bf 90       	pop	r11
 5d2:	af 90       	pop	r10
 5d4:	9f 90       	pop	r9
 5d6:	08 95       	ret

000005d8 <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE>:

	virtual uint16_t getMaxRefreshRate() const { return 400; }

protected:

	virtual void showPixels(PixelController<RGB_ORDER> & pixels) {
 5d8:	0f 93       	push	r16
 5da:	1f 93       	push	r17
 5dc:	cf 93       	push	r28
 5de:	df 93       	push	r29
 5e0:	ec 01       	movw	r28, r24
 5e2:	8b 01       	movw	r16, r22

	void wait() {
		uint16_t diff;
		do {
			diff = (micros() & 0xFFFF) - mLastMicros;
 5e4:	0e 94 9f 04 	call	0x93e	; 0x93e <micros>
public:
	CMinWait() { mLastMicros = 0; }

	void wait() {
		uint16_t diff;
		do {
 5e8:	2f 85       	ldd	r18, Y+15	; 0x0f
 5ea:	38 89       	ldd	r19, Y+16	; 0x10
 5ec:	62 1b       	sub	r22, r18
 5ee:	73 0b       	sbc	r23, r19
 5f0:	6a 30       	cpi	r22, 0x0A	; 10
 5f2:	71 05       	cpc	r23, r1
 5f4:	b8 f3       	brcs	.-18     	; 0x5e4 <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0xc>

		mWait.wait();
		cli();
 5f6:	f8 94       	cli

		showRGBInternal(pixels);
 5f8:	c8 01       	movw	r24, r16
 5fa:	0e 94 08 01 	call	0x210	; 0x210 <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE15showRGBInternalER15PixelControllerILS0_66ELi1ELm4294967295EE>
                case BINARY_DITHER: init_binary_dithering(); break;
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
            }
        }

        __attribute__((always_inline)) inline int size() { return mLen; }
 5fe:	f8 01       	movw	r30, r16
 600:	42 81       	ldd	r20, Z+2	; 0x02
 602:	53 81       	ldd	r21, Z+3	; 0x03

		// Adjust the timer
#if (!defined(NO_CORRECTION) || (NO_CORRECTION == 0)) && (FASTLED_ALLOW_INTERRUPTS == 0)
        uint32_t microsTaken = (uint32_t)pixels.size() * (uint32_t)CLKS_TO_MICROS(24 * (T1 + T2 + T3));
 604:	20 ee       	ldi	r18, 0xE0	; 224
 606:	31 e0       	ldi	r19, 0x01	; 1
 608:	da 01       	movw	r26, r20
 60a:	0e 94 6f 07 	call	0xede	; 0xede <__usmulhisi3>
 60e:	dc 01       	movw	r26, r24
 610:	cb 01       	movw	r24, r22
 612:	f4 e0       	ldi	r31, 0x04	; 4
 614:	b6 95       	lsr	r27
 616:	a7 95       	ror	r26
 618:	97 95       	ror	r25
 61a:	87 95       	ror	r24
 61c:	fa 95       	dec	r31
 61e:	d1 f7       	brne	.-12     	; 0x614 <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0x3c>
         "  clr __zero_reg__                    \n\t"

         : [result] "+r" (result)
         : [i] "r" (i), [scale] "r" (scale)
         : "r0", "r1"
         );
 620:	20 e0       	ldi	r18, 0x00	; 0
 622:	30 e0       	ldi	r19, 0x00	; 0
 624:	b9 01       	movw	r22, r18
 626:	ea e9       	ldi	r30, 0x9A	; 154
 628:	4e 9f       	mul	r20, r30
 62a:	61 2d       	mov	r22, r1
 62c:	5e 9f       	mul	r21, r30
 62e:	60 0d       	add	r22, r0
 630:	71 1d       	adc	r23, r1
 632:	11 24       	eor	r1, r1

        // adust for approximate observed actal runtime (as of January 2015)
        // roughly 9.6 cycles per pixel, which is 0.6us/pixel at 16MHz
        // microsTaken += nLeds * 0.6 * CLKS_TO_MICROS(16);
        microsTaken += scale16by8(pixels.size(),(0.6 * 256) + 1) * CLKS_TO_MICROS(16);
 634:	86 0f       	add	r24, r22
 636:	97 1f       	adc	r25, r23
 638:	a1 1d       	adc	r26, r1
 63a:	b1 1d       	adc	r27, r1
        // this is because the ONE interrupt that might come in while interrupts
        // are disabled is queued up, and it will be serviced as soon as
        // interrupts are re-enabled.
        // This actually should technically also account for the runtime of the
        // interrupt handler itself, but we're just not going to worry about that.
        if( microsTaken > 1000) {
 63c:	89 3e       	cpi	r24, 0xE9	; 233
 63e:	f3 e0       	ldi	r31, 0x03	; 3
 640:	9f 07       	cpc	r25, r31
 642:	a1 05       	cpc	r26, r1
 644:	b1 05       	cpc	r27, r1
 646:	88 f1       	brcs	.+98     	; 0x6aa <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0xd2>
            microsTaken -= 1000;

            // Now convert microseconds to 256ths of a second, approximately like this:
            // 250ths = (us/4)
            // 256ths = 250ths * (263/256);
            uint16_t x256ths = microsTaken >> 2;
 648:	88 5e       	subi	r24, 0xE8	; 232
 64a:	93 40       	sbci	r25, 0x03	; 3
 64c:	a1 09       	sbc	r26, r1
 64e:	b1 09       	sbc	r27, r1
 650:	42 e0       	ldi	r20, 0x02	; 2
 652:	b6 95       	lsr	r27
 654:	a7 95       	ror	r26
 656:	97 95       	ror	r25
 658:	87 95       	ror	r24
 65a:	4a 95       	dec	r20
 65c:	d1 f7       	brne	.-12     	; 0x652 <_ZN19ClocklessControllerILh3ELi4ELi10ELi6EL6EOrder66ELi0ELb0ELi10EE10showPixelsER15PixelControllerILS0_66ELi1ELm4294967295EE+0x7a>
 65e:	47 e0       	ldi	r20, 0x07	; 7
 660:	84 9f       	mul	r24, r20
 662:	21 2d       	mov	r18, r1
 664:	94 9f       	mul	r25, r20
 666:	20 0d       	add	r18, r0
 668:	31 1d       	adc	r19, r1
 66a:	11 24       	eor	r1, r1
 66c:	60 91 2f 01 	lds	r22, 0x012F	; 0x80012f <_ZL21gTimeErrorAccum256ths>
 670:	70 e0       	ldi	r23, 0x00	; 0
 672:	86 0f       	add	r24, r22
 674:	97 1f       	adc	r25, r23
            x256ths += scale16by8(x256ths,7);

            x256ths += gTimeErrorAccum256ths;
 676:	82 0f       	add	r24, r18
 678:	93 1f       	adc	r25, r19
            MS_COUNTER += (x256ths >> 8);
 67a:	40 91 31 01 	lds	r20, 0x0131	; 0x800131 <timer0_millis>
 67e:	50 91 32 01 	lds	r21, 0x0132	; 0x800132 <timer0_millis+0x1>
 682:	60 91 33 01 	lds	r22, 0x0133	; 0x800133 <timer0_millis+0x2>
 686:	70 91 34 01 	lds	r23, 0x0134	; 0x800134 <timer0_millis+0x3>
 68a:	29 2f       	mov	r18, r25
 68c:	33 27       	eor	r19, r19
 68e:	42 0f       	add	r20, r18
 690:	53 1f       	adc	r21, r19
 692:	61 1d       	adc	r22, r1
 694:	71 1d       	adc	r23, r1
 696:	40 93 31 01 	sts	0x0131, r20	; 0x800131 <timer0_millis>
 69a:	50 93 32 01 	sts	0x0132, r21	; 0x800132 <timer0_millis+0x1>
 69e:	60 93 33 01 	sts	0x0133, r22	; 0x800133 <timer0_millis+0x2>
 6a2:	70 93 34 01 	sts	0x0134, r23	; 0x800134 <timer0_millis+0x3>
            gTimeErrorAccum256ths = x256ths & 0xFF;
 6a6:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <_ZL21gTimeErrorAccum256ths>
        MS_COUNTER += (microsTaken >> 10);
#endif

#endif

		sei();
 6aa:	78 94       	sei
			diff = (micros() & 0xFFFF) - mLastMicros;
		} while(diff < WAIT);
	}

	void mark() { mLastMicros = micros() & 0xFFFF; }
 6ac:	0e 94 9f 04 	call	0x93e	; 0x93e <micros>
 6b0:	78 8b       	std	Y+16, r23	; 0x10
 6b2:	6f 87       	std	Y+15, r22	; 0x0f
		mWait.mark();
	}
 6b4:	df 91       	pop	r29
 6b6:	cf 91       	pop	r28
 6b8:	1f 91       	pop	r17
 6ba:	0f 91       	pop	r16
 6bc:	08 95       	ret

000006be <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE11initOffsetsEi>:
        }

        void initOffsets(int len) {
          int nOffset = 0;
          for(int i = 0; i < LANES; i++) {
            mOffsets[i] = nOffset;
 6be:	fc 01       	movw	r30, r24
 6c0:	11 8a       	std	Z+17, r1	; 0x11
 6c2:	10 8a       	std	Z+16, r1	; 0x10
 6c4:	08 95       	ret

000006c6 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv>:
            enable_dithering(dither);
            mAdvance = 0;
            initOffsets(len);
        }

        void init_binary_dithering() {
 6c6:	0f 93       	push	r16
 6c8:	1f 93       	push	r17
 6ca:	cf 93       	push	r28
 6cc:	df 93       	push	r29
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            byte ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
 6ce:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <__data_end>
 6d2:	2f 5f       	subi	r18, 0xFF	; 255
 6d4:	32 2f       	mov	r19, r18
 6d6:	37 70       	andi	r19, 0x07	; 7
 6d8:	30 93 12 01 	sts	0x0112, r19	; 0x800112 <__data_end>
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
 6dc:	20 ff       	sbrs	r18, 0
 6de:	02 c0       	rjmp	.+4      	; 0x6e4 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x1e>
 6e0:	20 e8       	ldi	r18, 0x80	; 128
 6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x20>
            R &= (0x01 << ditherBits) - 1;

            // Q is the "unscaled dither signal" itself.
            // It's initialized to the reversed bits of R.
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;
 6e4:	20 e0       	ldi	r18, 0x00	; 0

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
                if(R & 0x02) { Q |= 0x40; }
 6e6:	31 fd       	sbrc	r19, 1
 6e8:	20 64       	ori	r18, 0x40	; 64
                if(R & 0x04) { Q |= 0x20; }
 6ea:	34 70       	andi	r19, 0x04	; 4
 6ec:	09 f0       	breq	.+2      	; 0x6f0 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x2a>
 6ee:	20 62       	ori	r18, 0x20	; 32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
 6f0:	20 5f       	subi	r18, 0xF0	; 240
 6f2:	fc 01       	movw	r30, r24
 6f4:	ec 01       	movw	r28, r24
 6f6:	23 96       	adiw	r28, 0x03	; 3
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
 6f8:	00 e0       	ldi	r16, 0x00	; 0
 6fa:	11 e0       	ldi	r17, 0x01	; 1
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
 6fc:	64 85       	ldd	r22, Z+12	; 0x0c
                    e[i] = s ? (256/s) + 1 : 0;
 6fe:	66 23       	and	r22, r22
 700:	31 f0       	breq	.+12     	; 0x70e <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x48>
 702:	70 e0       	ldi	r23, 0x00	; 0
 704:	c8 01       	movw	r24, r16
 706:	0e 94 1a 07 	call	0xe34	; 0xe34 <__divmodhi4>
 70a:	6f 5f       	subi	r22, 0xFF	; 255
 70c:	01 c0       	rjmp	.+2      	; 0x710 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x4a>
 70e:	60 e0       	ldi	r22, 0x00	; 0
 710:	61 87       	std	Z+9, r22	; 0x09
#endif
         "clr __zero_reg__    \n\t"

         : "+a" (i)      /* writes to i */
         : "a"  (scale)  /* uses scale */
         : "r0", "r1"    /* clobbers r0, r1 */ );
 712:	32 2f       	mov	r19, r18
 714:	36 9f       	mul	r19, r22
 716:	03 0e       	add	r0, r19
 718:	30 e0       	ldi	r19, 0x00	; 0
 71a:	31 1d       	adc	r19, r1
 71c:	11 24       	eor	r1, r1
                    d[i] = scale8(Q, e[i]);
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
 71e:	31 11       	cpse	r19, r1
 720:	02 c0       	rjmp	.+4      	; 0x726 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x60>

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
                    d[i] = scale8(Q, e[i]);
 722:	16 82       	std	Z+6, r1	; 0x06
 724:	02 c0       	rjmp	.+4      	; 0x72a <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x64>
#if (FASTLED_SCALE8_FIXED == 1)
                    if(d[i]) (d[i]--);
 726:	31 50       	subi	r19, 0x01	; 1
 728:	36 83       	std	Z+6, r19	; 0x06
#endif
                    if(e[i]) e[i]--;
 72a:	66 23       	and	r22, r22
 72c:	11 f0       	breq	.+4      	; 0x732 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x6c>
 72e:	61 50       	subi	r22, 0x01	; 1
 730:	61 87       	std	Z+9, r22	; 0x09
 732:	31 96       	adiw	r30, 0x01	; 1
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
 734:	ce 17       	cp	r28, r30
 736:	df 07       	cpc	r29, r31
 738:	09 f7       	brne	.-62     	; 0x6fc <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv+0x36>
                    if(d[i]) (d[i]--);
#endif
                    if(e[i]) e[i]--;
            }
#endif
        }
 73a:	df 91       	pop	r29
 73c:	cf 91       	pop	r28
 73e:	1f 91       	pop	r17
 740:	0f 91       	pop	r16
 742:	08 95       	ret

00000744 <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE4showEPK4CRGBiS2_>:

/// write the passed in rgb data out to the leds managed by this controller
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
 744:	ef 92       	push	r14
 746:	ff 92       	push	r15
 748:	0f 93       	push	r16
 74a:	1f 93       	push	r17
 74c:	cf 93       	push	r28
 74e:	df 93       	push	r29
 750:	cd b7       	in	r28, 0x3d	; 61
 752:	de b7       	in	r29, 0x3e	; 62
 754:	62 97       	sbiw	r28, 0x12	; 18
 756:	0f b6       	in	r0, 0x3f	; 63
 758:	f8 94       	cli
 75a:	de bf       	out	0x3e, r29	; 62
 75c:	0f be       	out	0x3f, r0	; 63
 75e:	cd bf       	out	0x3d, r28	; 61
 760:	8c 01       	movw	r16, r24
 762:	7a 01       	movw	r14, r20
 764:	f9 01       	movw	r30, r18
 766:	dc 01       	movw	r26, r24
 768:	1c 96       	adiw	r26, 0x0c	; 12
 76a:	8c 91       	ld	r24, X
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
 76c:	7a 83       	std	Y+2, r23	; 0x02
 76e:	69 83       	std	Y+1, r22	; 0x01
 770:	5c 83       	std	Y+4, r21	; 0x04
 772:	4b 83       	std	Y+3, r20	; 0x03
 774:	5e 83       	std	Y+6, r21	; 0x06
 776:	4d 83       	std	Y+5, r20	; 0x05
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 778:	90 81       	ld	r25, Z
 77a:	9d 87       	std	Y+13, r25	; 0x0d
        g = rhs.g;
 77c:	91 81       	ldd	r25, Z+1	; 0x01
 77e:	9e 87       	std	Y+14, r25	; 0x0e
        b = rhs.b;
 780:	92 81       	ldd	r25, Z+2	; 0x02
 782:	9f 87       	std	Y+15, r25	; 0x0f
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 784:	81 30       	cpi	r24, 0x01	; 1
 786:	29 f4       	brne	.+10     	; 0x792 <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE4showEPK4CRGBiS2_+0x4e>
                case BINARY_DITHER: init_binary_dithering(); break;
 788:	ce 01       	movw	r24, r28
 78a:	01 96       	adiw	r24, 0x01	; 1
 78c:	0e 94 63 03 	call	0x6c6	; 0x6c6 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv>
 790:	06 c0       	rjmp	.+12     	; 0x79e <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE4showEPK4CRGBiS2_+0x5a>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
 792:	1c 86       	std	Y+12, r1	; 0x0c
 794:	1b 86       	std	Y+11, r1	; 0x0b
 796:	1a 86       	std	Y+10, r1	; 0x0a
 798:	19 86       	std	Y+9, r1	; 0x09
 79a:	18 86       	std	Y+8, r1	; 0x08
 79c:	1f 82       	std	Y+7, r1	; 0x07
            initOffsets(len);
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
 79e:	83 e0       	ldi	r24, 0x03	; 3
 7a0:	88 8b       	std	Y+16, r24	; 0x10
            initOffsets(len);
 7a2:	b7 01       	movw	r22, r14
 7a4:	ce 01       	movw	r24, r28
 7a6:	01 96       	adiw	r24, 0x01	; 1
 7a8:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE11initOffsetsEi>
///@param data the rgb data to write out to the strip
///@param nLeds the number of leds being written out
///@param scale the rgb scaling to apply to each led before writing it out
  virtual void show(const struct CRGB *data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
 7ac:	d8 01       	movw	r26, r16
 7ae:	ed 91       	ld	r30, X+
 7b0:	fc 91       	ld	r31, X
 7b2:	04 84       	ldd	r0, Z+12	; 0x0c
 7b4:	f5 85       	ldd	r31, Z+13	; 0x0d
 7b6:	e0 2d       	mov	r30, r0
 7b8:	be 01       	movw	r22, r28
 7ba:	6f 5f       	subi	r22, 0xFF	; 255
 7bc:	7f 4f       	sbci	r23, 0xFF	; 255
 7be:	c8 01       	movw	r24, r16
 7c0:	09 95       	icall
  }
 7c2:	62 96       	adiw	r28, 0x12	; 18
 7c4:	0f b6       	in	r0, 0x3f	; 63
 7c6:	f8 94       	cli
 7c8:	de bf       	out	0x3e, r29	; 62
 7ca:	0f be       	out	0x3f, r0	; 63
 7cc:	cd bf       	out	0x3d, r28	; 61
 7ce:	df 91       	pop	r29
 7d0:	cf 91       	pop	r28
 7d2:	1f 91       	pop	r17
 7d4:	0f 91       	pop	r16
 7d6:	ff 90       	pop	r15
 7d8:	ef 90       	pop	r14
 7da:	08 95       	ret

000007dc <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE9showColorERK4CRGBiS2_>:

  /// set all the leds on the controller to a given color
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
 7dc:	ef 92       	push	r14
 7de:	ff 92       	push	r15
 7e0:	0f 93       	push	r16
 7e2:	1f 93       	push	r17
 7e4:	cf 93       	push	r28
 7e6:	df 93       	push	r29
 7e8:	cd b7       	in	r28, 0x3d	; 61
 7ea:	de b7       	in	r29, 0x3e	; 62
 7ec:	62 97       	sbiw	r28, 0x12	; 18
 7ee:	0f b6       	in	r0, 0x3f	; 63
 7f0:	f8 94       	cli
 7f2:	de bf       	out	0x3e, r29	; 62
 7f4:	0f be       	out	0x3f, r0	; 63
 7f6:	cd bf       	out	0x3d, r28	; 61
 7f8:	8c 01       	movw	r16, r24
 7fa:	7a 01       	movw	r14, r20
 7fc:	f9 01       	movw	r30, r18
 7fe:	dc 01       	movw	r26, r24
 800:	1c 96       	adiw	r26, 0x0c	; 12
 802:	8c 91       	ld	r24, X
            enable_dithering(dither);
            mAdvance = 3;
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
 804:	7a 83       	std	Y+2, r23	; 0x02
 806:	69 83       	std	Y+1, r22	; 0x01
 808:	5c 83       	std	Y+4, r21	; 0x04
 80a:	4b 83       	std	Y+3, r20	; 0x03
 80c:	5e 83       	std	Y+6, r21	; 0x06
 80e:	4d 83       	std	Y+5, r20	; 0x05
    }

    /// allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 810:	90 81       	ld	r25, Z
 812:	9d 87       	std	Y+13, r25	; 0x0d
        g = rhs.g;
 814:	91 81       	ldd	r25, Z+1	; 0x01
 816:	9e 87       	std	Y+14, r25	; 0x0e
        b = rhs.b;
 818:	92 81       	ldd	r25, Z+2	; 0x02
 81a:	9f 87       	std	Y+15, r25	; 0x0f
            return mLenRemaining >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 81c:	81 30       	cpi	r24, 0x01	; 1
 81e:	29 f4       	brne	.+10     	; 0x82a <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE9showColorERK4CRGBiS2_+0x4e>
                case BINARY_DITHER: init_binary_dithering(); break;
 820:	ce 01       	movw	r24, r28
 822:	01 96       	adiw	r24, 0x01	; 1
 824:	0e 94 63 03 	call	0x6c6	; 0x6c6 <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE21init_binary_ditheringEv>
 828:	06 c0       	rjmp	.+12     	; 0x836 <_ZN19CPixelLEDControllerIL6EOrder66ELi1ELm4294967295EE9showColorERK4CRGBiS2_+0x5a>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
 82a:	1c 86       	std	Y+12, r1	; 0x0c
 82c:	1b 86       	std	Y+11, r1	; 0x0b
 82e:	1a 86       	std	Y+10, r1	; 0x0a
 830:	19 86       	std	Y+9, r1	; 0x09
 832:	18 86       	std	Y+8, r1	; 0x08
 834:	1f 82       	std	Y+7, r1	; 0x07
            initOffsets(len);
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mLenRemaining(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 0;
 836:	18 8a       	std	Y+16, r1	; 0x10
            initOffsets(len);
 838:	b7 01       	movw	r22, r14
 83a:	ce 01       	movw	r24, r28
 83c:	01 96       	adiw	r24, 0x01	; 1
 83e:	0e 94 5f 03 	call	0x6be	; 0x6be <_ZN15PixelControllerIL6EOrder66ELi1ELm4294967295EE11initOffsetsEi>
  ///@param data the crgb color to set the leds to
  ///@param nLeds the numner of leds to set to this color
  ///@param scale the rgb scaling value for outputting color
  virtual void showColor(const struct CRGB & data, int nLeds, CRGB scale) {
    PixelController<RGB_ORDER, LANES, MASK> pixels(data, nLeds, scale, getDither());
    showPixels(pixels);
 842:	d8 01       	movw	r26, r16
 844:	ed 91       	ld	r30, X+
 846:	fc 91       	ld	r31, X
 848:	04 84       	ldd	r0, Z+12	; 0x0c
 84a:	f5 85       	ldd	r31, Z+13	; 0x0d
 84c:	e0 2d       	mov	r30, r0
 84e:	be 01       	movw	r22, r28
 850:	6f 5f       	subi	r22, 0xFF	; 255
 852:	7f 4f       	sbci	r23, 0xFF	; 255
 854:	c8 01       	movw	r24, r16
 856:	09 95       	icall
  }
 858:	62 96       	adiw	r28, 0x12	; 18
 85a:	0f b6       	in	r0, 0x3f	; 63
 85c:	f8 94       	cli
 85e:	de bf       	out	0x3e, r29	; 62
 860:	0f be       	out	0x3f, r0	; 63
 862:	cd bf       	out	0x3d, r28	; 61
 864:	df 91       	pop	r29
 866:	cf 91       	pop	r28
 868:	1f 91       	pop	r17
 86a:	0f 91       	pop	r16
 86c:	ff 90       	pop	r15
 86e:	ef 90       	pop	r14
 870:	08 95       	ret

00000872 <initVariant>:
 872:	08 95       	ret

00000874 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
 874:	0e 94 00 05 	call	0xa00	; 0xa00 <init>

	initVariant();
 878:	0e 94 39 04 	call	0x872	; 0x872 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 87c:	0e 94 8c 00 	call	0x118	; 0x118 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 880:	c0 e0       	ldi	r28, 0x00	; 0
 882:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
 884:	0e 94 df 00 	call	0x1be	; 0x1be <loop>
		if (serialEventRun) serialEventRun();
 888:	20 97       	sbiw	r28, 0x00	; 0
 88a:	e1 f3       	breq	.-8      	; 0x884 <main+0x10>
 88c:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 890:	f9 cf       	rjmp	.-14     	; 0x884 <main+0x10>

00000892 <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
 892:	1f 92       	push	r1
 894:	0f 92       	push	r0
 896:	0f b6       	in	r0, 0x3f	; 63
 898:	0f 92       	push	r0
 89a:	11 24       	eor	r1, r1
 89c:	2f 93       	push	r18
 89e:	3f 93       	push	r19
 8a0:	8f 93       	push	r24
 8a2:	9f 93       	push	r25
 8a4:	af 93       	push	r26
 8a6:	bf 93       	push	r27
 8a8:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <timer0_millis>
 8ac:	90 91 32 01 	lds	r25, 0x0132	; 0x800132 <timer0_millis+0x1>
 8b0:	a0 91 33 01 	lds	r26, 0x0133	; 0x800133 <timer0_millis+0x2>
 8b4:	b0 91 34 01 	lds	r27, 0x0134	; 0x800134 <timer0_millis+0x3>
 8b8:	30 91 30 01 	lds	r19, 0x0130	; 0x800130 <timer0_fract>
 8bc:	23 e0       	ldi	r18, 0x03	; 3
 8be:	23 0f       	add	r18, r19
 8c0:	2d 37       	cpi	r18, 0x7D	; 125
 8c2:	20 f4       	brcc	.+8      	; 0x8cc <__vector_16+0x3a>
 8c4:	01 96       	adiw	r24, 0x01	; 1
 8c6:	a1 1d       	adc	r26, r1
 8c8:	b1 1d       	adc	r27, r1
 8ca:	05 c0       	rjmp	.+10     	; 0x8d6 <__vector_16+0x44>
 8cc:	26 e8       	ldi	r18, 0x86	; 134
 8ce:	23 0f       	add	r18, r19
 8d0:	02 96       	adiw	r24, 0x02	; 2
 8d2:	a1 1d       	adc	r26, r1
 8d4:	b1 1d       	adc	r27, r1
 8d6:	20 93 30 01 	sts	0x0130, r18	; 0x800130 <timer0_fract>
 8da:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <timer0_millis>
 8de:	90 93 32 01 	sts	0x0132, r25	; 0x800132 <timer0_millis+0x1>
 8e2:	a0 93 33 01 	sts	0x0133, r26	; 0x800133 <timer0_millis+0x2>
 8e6:	b0 93 34 01 	sts	0x0134, r27	; 0x800134 <timer0_millis+0x3>
 8ea:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <timer0_overflow_count>
 8ee:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <timer0_overflow_count+0x1>
 8f2:	a0 91 37 01 	lds	r26, 0x0137	; 0x800137 <timer0_overflow_count+0x2>
 8f6:	b0 91 38 01 	lds	r27, 0x0138	; 0x800138 <timer0_overflow_count+0x3>
 8fa:	01 96       	adiw	r24, 0x01	; 1
 8fc:	a1 1d       	adc	r26, r1
 8fe:	b1 1d       	adc	r27, r1
 900:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <timer0_overflow_count>
 904:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <timer0_overflow_count+0x1>
 908:	a0 93 37 01 	sts	0x0137, r26	; 0x800137 <timer0_overflow_count+0x2>
 90c:	b0 93 38 01 	sts	0x0138, r27	; 0x800138 <timer0_overflow_count+0x3>
 910:	bf 91       	pop	r27
 912:	af 91       	pop	r26
 914:	9f 91       	pop	r25
 916:	8f 91       	pop	r24
 918:	3f 91       	pop	r19
 91a:	2f 91       	pop	r18
 91c:	0f 90       	pop	r0
 91e:	0f be       	out	0x3f, r0	; 63
 920:	0f 90       	pop	r0
 922:	1f 90       	pop	r1
 924:	18 95       	reti

00000926 <millis>:
 926:	2f b7       	in	r18, 0x3f	; 63
 928:	f8 94       	cli
 92a:	60 91 31 01 	lds	r22, 0x0131	; 0x800131 <timer0_millis>
 92e:	70 91 32 01 	lds	r23, 0x0132	; 0x800132 <timer0_millis+0x1>
 932:	80 91 33 01 	lds	r24, 0x0133	; 0x800133 <timer0_millis+0x2>
 936:	90 91 34 01 	lds	r25, 0x0134	; 0x800134 <timer0_millis+0x3>
 93a:	2f bf       	out	0x3f, r18	; 63
 93c:	08 95       	ret

0000093e <micros>:
 93e:	3f b7       	in	r19, 0x3f	; 63
 940:	f8 94       	cli
 942:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <timer0_overflow_count>
 946:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <timer0_overflow_count+0x1>
 94a:	a0 91 37 01 	lds	r26, 0x0137	; 0x800137 <timer0_overflow_count+0x2>
 94e:	b0 91 38 01 	lds	r27, 0x0138	; 0x800138 <timer0_overflow_count+0x3>
 952:	26 b5       	in	r18, 0x26	; 38
 954:	a8 9b       	sbis	0x15, 0	; 21
 956:	05 c0       	rjmp	.+10     	; 0x962 <micros+0x24>
 958:	2f 3f       	cpi	r18, 0xFF	; 255
 95a:	19 f0       	breq	.+6      	; 0x962 <micros+0x24>
 95c:	01 96       	adiw	r24, 0x01	; 1
 95e:	a1 1d       	adc	r26, r1
 960:	b1 1d       	adc	r27, r1
 962:	3f bf       	out	0x3f, r19	; 63
 964:	ba 2f       	mov	r27, r26
 966:	a9 2f       	mov	r26, r25
 968:	98 2f       	mov	r25, r24
 96a:	88 27       	eor	r24, r24
 96c:	82 0f       	add	r24, r18
 96e:	91 1d       	adc	r25, r1
 970:	a1 1d       	adc	r26, r1
 972:	b1 1d       	adc	r27, r1
 974:	bc 01       	movw	r22, r24
 976:	cd 01       	movw	r24, r26
 978:	42 e0       	ldi	r20, 0x02	; 2
 97a:	66 0f       	add	r22, r22
 97c:	77 1f       	adc	r23, r23
 97e:	88 1f       	adc	r24, r24
 980:	99 1f       	adc	r25, r25
 982:	4a 95       	dec	r20
 984:	d1 f7       	brne	.-12     	; 0x97a <micros+0x3c>
 986:	08 95       	ret

00000988 <delay>:
 988:	8f 92       	push	r8
 98a:	9f 92       	push	r9
 98c:	af 92       	push	r10
 98e:	bf 92       	push	r11
 990:	cf 92       	push	r12
 992:	df 92       	push	r13
 994:	ef 92       	push	r14
 996:	ff 92       	push	r15
 998:	6b 01       	movw	r12, r22
 99a:	7c 01       	movw	r14, r24
 99c:	0e 94 9f 04 	call	0x93e	; 0x93e <micros>
 9a0:	4b 01       	movw	r8, r22
 9a2:	5c 01       	movw	r10, r24
 9a4:	c1 14       	cp	r12, r1
 9a6:	d1 04       	cpc	r13, r1
 9a8:	e1 04       	cpc	r14, r1
 9aa:	f1 04       	cpc	r15, r1
 9ac:	01 f1       	breq	.+64     	; 0x9ee <delay+0x66>
 9ae:	0e 94 09 07 	call	0xe12	; 0xe12 <yield>
 9b2:	0e 94 9f 04 	call	0x93e	; 0x93e <micros>
 9b6:	dc 01       	movw	r26, r24
 9b8:	cb 01       	movw	r24, r22
 9ba:	88 19       	sub	r24, r8
 9bc:	99 09       	sbc	r25, r9
 9be:	aa 09       	sbc	r26, r10
 9c0:	bb 09       	sbc	r27, r11
 9c2:	88 3e       	cpi	r24, 0xE8	; 232
 9c4:	93 40       	sbci	r25, 0x03	; 3
 9c6:	a1 05       	cpc	r26, r1
 9c8:	b1 05       	cpc	r27, r1
 9ca:	60 f3       	brcs	.-40     	; 0x9a4 <delay+0x1c>
 9cc:	21 e0       	ldi	r18, 0x01	; 1
 9ce:	c2 1a       	sub	r12, r18
 9d0:	d1 08       	sbc	r13, r1
 9d2:	e1 08       	sbc	r14, r1
 9d4:	f1 08       	sbc	r15, r1
 9d6:	88 ee       	ldi	r24, 0xE8	; 232
 9d8:	88 0e       	add	r8, r24
 9da:	83 e0       	ldi	r24, 0x03	; 3
 9dc:	98 1e       	adc	r9, r24
 9de:	a1 1c       	adc	r10, r1
 9e0:	b1 1c       	adc	r11, r1
 9e2:	c1 14       	cp	r12, r1
 9e4:	d1 04       	cpc	r13, r1
 9e6:	e1 04       	cpc	r14, r1
 9e8:	f1 04       	cpc	r15, r1
 9ea:	19 f7       	brne	.-58     	; 0x9b2 <delay+0x2a>
 9ec:	db cf       	rjmp	.-74     	; 0x9a4 <delay+0x1c>
 9ee:	ff 90       	pop	r15
 9f0:	ef 90       	pop	r14
 9f2:	df 90       	pop	r13
 9f4:	cf 90       	pop	r12
 9f6:	bf 90       	pop	r11
 9f8:	af 90       	pop	r10
 9fa:	9f 90       	pop	r9
 9fc:	8f 90       	pop	r8
 9fe:	08 95       	ret

00000a00 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 a00:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 a02:	84 b5       	in	r24, 0x24	; 36
 a04:	82 60       	ori	r24, 0x02	; 2
 a06:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 a08:	84 b5       	in	r24, 0x24	; 36
 a0a:	81 60       	ori	r24, 0x01	; 1
 a0c:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 a0e:	85 b5       	in	r24, 0x25	; 37
 a10:	82 60       	ori	r24, 0x02	; 2
 a12:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 a14:	85 b5       	in	r24, 0x25	; 37
 a16:	81 60       	ori	r24, 0x01	; 1
 a18:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 a1a:	ee e6       	ldi	r30, 0x6E	; 110
 a1c:	f0 e0       	ldi	r31, 0x00	; 0
 a1e:	80 81       	ld	r24, Z
 a20:	81 60       	ori	r24, 0x01	; 1
 a22:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 a24:	e1 e8       	ldi	r30, 0x81	; 129
 a26:	f0 e0       	ldi	r31, 0x00	; 0
 a28:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 a2a:	80 81       	ld	r24, Z
 a2c:	82 60       	ori	r24, 0x02	; 2
 a2e:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 a30:	80 81       	ld	r24, Z
 a32:	81 60       	ori	r24, 0x01	; 1
 a34:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 a36:	e0 e8       	ldi	r30, 0x80	; 128
 a38:	f0 e0       	ldi	r31, 0x00	; 0
 a3a:	80 81       	ld	r24, Z
 a3c:	81 60       	ori	r24, 0x01	; 1
 a3e:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 a40:	e1 eb       	ldi	r30, 0xB1	; 177
 a42:	f0 e0       	ldi	r31, 0x00	; 0
 a44:	80 81       	ld	r24, Z
 a46:	84 60       	ori	r24, 0x04	; 4
 a48:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 a4a:	e0 eb       	ldi	r30, 0xB0	; 176
 a4c:	f0 e0       	ldi	r31, 0x00	; 0
 a4e:	80 81       	ld	r24, Z
 a50:	81 60       	ori	r24, 0x01	; 1
 a52:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 a54:	ea e7       	ldi	r30, 0x7A	; 122
 a56:	f0 e0       	ldi	r31, 0x00	; 0
 a58:	80 81       	ld	r24, Z
 a5a:	84 60       	ori	r24, 0x04	; 4
 a5c:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 a5e:	80 81       	ld	r24, Z
 a60:	82 60       	ori	r24, 0x02	; 2
 a62:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 a64:	80 81       	ld	r24, Z
 a66:	81 60       	ori	r24, 0x01	; 1
 a68:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 a6a:	80 81       	ld	r24, Z
 a6c:	80 68       	ori	r24, 0x80	; 128
 a6e:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 a70:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
 a74:	08 95       	ret

00000a76 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_>:
  } else {
    m_nMinMicros = 0;
  }
}

extern "C" int atexit(void (* /*func*/ )()) { return 0; }
 a76:	8f 92       	push	r8
 a78:	9f 92       	push	r9
 a7a:	af 92       	push	r10
 a7c:	bf 92       	push	r11
 a7e:	cf 92       	push	r12
 a80:	df 92       	push	r13
 a82:	ef 92       	push	r14
 a84:	ff 92       	push	r15
 a86:	0f 93       	push	r16
 a88:	1f 93       	push	r17
 a8a:	cf 93       	push	r28
 a8c:	df 93       	push	r29
 a8e:	ec 01       	movw	r28, r24
 a90:	18 82       	st	Y, r1
 a92:	19 82       	std	Y+1, r1	; 0x01
 a94:	1a 82       	std	Y+2, r1	; 0x02
 a96:	66 23       	and	r22, r22
 a98:	c1 f1       	breq	.+112    	; 0xb0a <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x94>
 a9a:	fa 01       	movw	r30, r20
 a9c:	89 01       	movw	r16, r18
 a9e:	7c 01       	movw	r14, r24
 aa0:	6a 01       	movw	r12, r20
 aa2:	83 e0       	ldi	r24, 0x03	; 3
 aa4:	c8 0e       	add	r12, r24
 aa6:	d1 1c       	adc	r13, r1
 aa8:	86 2e       	mov	r8, r22
 aaa:	91 2c       	mov	r9, r1
 aac:	a1 2c       	mov	r10, r1
 aae:	b1 2c       	mov	r11, r1
 ab0:	21 91       	ld	r18, Z+
 ab2:	22 23       	and	r18, r18
 ab4:	11 f1       	breq	.+68     	; 0xafa <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x84>
 ab6:	d8 01       	movw	r26, r16
 ab8:	6c 91       	ld	r22, X
 aba:	66 23       	and	r22, r22
 abc:	f1 f0       	breq	.+60     	; 0xafa <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x84>
 abe:	82 2f       	mov	r24, r18
 ac0:	90 e0       	ldi	r25, 0x00	; 0
 ac2:	a0 e0       	ldi	r26, 0x00	; 0
 ac4:	b0 e0       	ldi	r27, 0x00	; 0
 ac6:	9c 01       	movw	r18, r24
 ac8:	ad 01       	movw	r20, r26
 aca:	2f 5f       	subi	r18, 0xFF	; 255
 acc:	3f 4f       	sbci	r19, 0xFF	; 255
 ace:	4f 4f       	sbci	r20, 0xFF	; 255
 ad0:	5f 4f       	sbci	r21, 0xFF	; 255
 ad2:	86 2f       	mov	r24, r22
 ad4:	90 e0       	ldi	r25, 0x00	; 0
 ad6:	a0 e0       	ldi	r26, 0x00	; 0
 ad8:	b0 e0       	ldi	r27, 0x00	; 0
 ada:	bc 01       	movw	r22, r24
 adc:	cd 01       	movw	r24, r26
 ade:	6f 5f       	subi	r22, 0xFF	; 255
 ae0:	7f 4f       	sbci	r23, 0xFF	; 255
 ae2:	8f 4f       	sbci	r24, 0xFF	; 255
 ae4:	9f 4f       	sbci	r25, 0xFF	; 255
 ae6:	0e 94 0a 07 	call	0xe14	; 0xe14 <__mulsi3>
 aea:	9b 01       	movw	r18, r22
 aec:	ac 01       	movw	r20, r24
 aee:	c5 01       	movw	r24, r10
 af0:	b4 01       	movw	r22, r8
 af2:	0e 94 0a 07 	call	0xe14	; 0xe14 <__mulsi3>
 af6:	d7 01       	movw	r26, r14
 af8:	8c 93       	st	X, r24
 afa:	0f 5f       	subi	r16, 0xFF	; 255
 afc:	1f 4f       	sbci	r17, 0xFF	; 255
 afe:	bf ef       	ldi	r27, 0xFF	; 255
 b00:	eb 1a       	sub	r14, r27
 b02:	fb 0a       	sbc	r15, r27
 b04:	ec 15       	cp	r30, r12
 b06:	fd 05       	cpc	r31, r13
 b08:	99 f6       	brne	.-90     	; 0xab0 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_+0x3a>
 b0a:	ce 01       	movw	r24, r28
 b0c:	df 91       	pop	r29
 b0e:	cf 91       	pop	r28
 b10:	1f 91       	pop	r17
 b12:	0f 91       	pop	r16
 b14:	ff 90       	pop	r15
 b16:	ef 90       	pop	r14
 b18:	df 90       	pop	r13
 b1a:	cf 90       	pop	r12
 b1c:	bf 90       	pop	r11
 b1e:	af 90       	pop	r10
 b20:	9f 90       	pop	r9
 b22:	8f 90       	pop	r8
 b24:	08 95       	ret

00000b26 <_ZN8CFastLEDC1Ev>:
 b26:	fc 01       	movw	r30, r24
 b28:	8f ef       	ldi	r24, 0xFF	; 255
 b2a:	80 83       	st	Z, r24
 b2c:	12 82       	std	Z+2, r1	; 0x02
 b2e:	11 82       	std	Z+1, r1	; 0x01
 b30:	14 86       	std	Z+12, r1	; 0x0c
 b32:	13 86       	std	Z+11, r1	; 0x0b
 b34:	8f ef       	ldi	r24, 0xFF	; 255
 b36:	9f ef       	ldi	r25, 0xFF	; 255
 b38:	dc 01       	movw	r26, r24
 b3a:	87 83       	std	Z+7, r24	; 0x07
 b3c:	90 87       	std	Z+8, r25	; 0x08
 b3e:	a1 87       	std	Z+9, r26	; 0x09
 b40:	b2 87       	std	Z+10, r27	; 0x0a
 b42:	08 95       	ret

00000b44 <_ZN8CFastLED8countFPSEi>:
 b44:	cf 92       	push	r12
 b46:	df 92       	push	r13
 b48:	ef 92       	push	r14
 b4a:	ff 92       	push	r15
 b4c:	0f 93       	push	r16
 b4e:	1f 93       	push	r17
 b50:	cf 93       	push	r28
 b52:	df 93       	push	r29
 b54:	20 91 3d 01 	lds	r18, 0x013D	; 0x80013d <_ZZN8CFastLED8countFPSEiE2br>
 b58:	30 91 3e 01 	lds	r19, 0x013E	; 0x80013e <_ZZN8CFastLED8countFPSEiE2br+0x1>
 b5c:	a9 01       	movw	r20, r18
 b5e:	4f 5f       	subi	r20, 0xFF	; 255
 b60:	5f 4f       	sbci	r21, 0xFF	; 255
 b62:	50 93 3e 01 	sts	0x013E, r21	; 0x80013e <_ZZN8CFastLED8countFPSEiE2br+0x1>
 b66:	40 93 3d 01 	sts	0x013D, r20	; 0x80013d <_ZZN8CFastLED8countFPSEiE2br>
 b6a:	26 17       	cp	r18, r22
 b6c:	37 07       	cpc	r19, r23
 b6e:	b4 f1       	brlt	.+108    	; 0xbdc <_ZN8CFastLED8countFPSEi+0x98>
 b70:	ec 01       	movw	r28, r24
 b72:	0e 94 93 04 	call	0x926	; 0x926 <millis>
 b76:	8b 01       	movw	r16, r22
 b78:	9c 01       	movw	r18, r24
 b7a:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <_ZZN8CFastLED8countFPSEiE2br>
 b7e:	f0 91 3e 01 	lds	r31, 0x013E	; 0x80013e <_ZZN8CFastLED8countFPSEiE2br+0x1>
 b82:	88 ee       	ldi	r24, 0xE8	; 232
 b84:	93 e0       	ldi	r25, 0x03	; 3
 b86:	e8 9f       	mul	r30, r24
 b88:	b0 01       	movw	r22, r0
 b8a:	e9 9f       	mul	r30, r25
 b8c:	70 0d       	add	r23, r0
 b8e:	f8 9f       	mul	r31, r24
 b90:	70 0d       	add	r23, r0
 b92:	11 24       	eor	r1, r1
 b94:	07 2e       	mov	r0, r23
 b96:	00 0c       	add	r0, r0
 b98:	88 0b       	sbc	r24, r24
 b9a:	99 0b       	sbc	r25, r25
 b9c:	c0 90 39 01 	lds	r12, 0x0139	; 0x800139 <_ZZN8CFastLED8countFPSEiE9lastframe>
 ba0:	d0 90 3a 01 	lds	r13, 0x013A	; 0x80013a <_ZZN8CFastLED8countFPSEiE9lastframe+0x1>
 ba4:	e0 90 3b 01 	lds	r14, 0x013B	; 0x80013b <_ZZN8CFastLED8countFPSEiE9lastframe+0x2>
 ba8:	f0 90 3c 01 	lds	r15, 0x013C	; 0x80013c <_ZZN8CFastLED8countFPSEiE9lastframe+0x3>
 bac:	a9 01       	movw	r20, r18
 bae:	98 01       	movw	r18, r16
 bb0:	2c 19       	sub	r18, r12
 bb2:	3d 09       	sbc	r19, r13
 bb4:	4e 09       	sbc	r20, r14
 bb6:	5f 09       	sbc	r21, r15
 bb8:	0e 94 2e 07 	call	0xe5c	; 0xe5c <__udivmodsi4>
 bbc:	3a 83       	std	Y+2, r19	; 0x02
 bbe:	29 83       	std	Y+1, r18	; 0x01
 bc0:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <_ZZN8CFastLED8countFPSEiE2br+0x1>
 bc4:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <_ZZN8CFastLED8countFPSEiE2br>
 bc8:	0e 94 93 04 	call	0x926	; 0x926 <millis>
 bcc:	60 93 39 01 	sts	0x0139, r22	; 0x800139 <_ZZN8CFastLED8countFPSEiE9lastframe>
 bd0:	70 93 3a 01 	sts	0x013A, r23	; 0x80013a <_ZZN8CFastLED8countFPSEiE9lastframe+0x1>
 bd4:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <_ZZN8CFastLED8countFPSEiE9lastframe+0x2>
 bd8:	90 93 3c 01 	sts	0x013C, r25	; 0x80013c <_ZZN8CFastLED8countFPSEiE9lastframe+0x3>
 bdc:	df 91       	pop	r29
 bde:	cf 91       	pop	r28
 be0:	1f 91       	pop	r17
 be2:	0f 91       	pop	r16
 be4:	ff 90       	pop	r15
 be6:	ef 90       	pop	r14
 be8:	df 90       	pop	r13
 bea:	cf 90       	pop	r12
 bec:	08 95       	ret

00000bee <_ZN8CFastLED4showEh>:
 bee:	af 92       	push	r10
 bf0:	bf 92       	push	r11
 bf2:	cf 92       	push	r12
 bf4:	df 92       	push	r13
 bf6:	ef 92       	push	r14
 bf8:	ff 92       	push	r15
 bfa:	0f 93       	push	r16
 bfc:	1f 93       	push	r17
 bfe:	cf 93       	push	r28
 c00:	df 93       	push	r29
 c02:	00 d0       	rcall	.+0      	; 0xc04 <_ZN8CFastLED4showEh+0x16>
 c04:	1f 92       	push	r1
 c06:	cd b7       	in	r28, 0x3d	; 61
 c08:	de b7       	in	r29, 0x3e	; 62
 c0a:	7c 01       	movw	r14, r24
 c0c:	d6 2e       	mov	r13, r22
 c0e:	f7 01       	movw	r30, r14
 c10:	83 81       	ldd	r24, Z+3	; 0x03
 c12:	94 81       	ldd	r25, Z+4	; 0x04
 c14:	a5 81       	ldd	r26, Z+5	; 0x05
 c16:	b6 81       	ldd	r27, Z+6	; 0x06
 c18:	89 2b       	or	r24, r25
 c1a:	8a 2b       	or	r24, r26
 c1c:	8b 2b       	or	r24, r27
 c1e:	d1 f0       	breq	.+52     	; 0xc54 <_ZN8CFastLED4showEh+0x66>
 c20:	0e 94 9f 04 	call	0x93e	; 0x93e <micros>
 c24:	00 91 3f 01 	lds	r16, 0x013F	; 0x80013f <_ZL8lastshow>
 c28:	10 91 40 01 	lds	r17, 0x0140	; 0x800140 <_ZL8lastshow+0x1>
 c2c:	20 91 41 01 	lds	r18, 0x0141	; 0x800141 <_ZL8lastshow+0x2>
 c30:	30 91 42 01 	lds	r19, 0x0142	; 0x800142 <_ZL8lastshow+0x3>
 c34:	dc 01       	movw	r26, r24
 c36:	cb 01       	movw	r24, r22
 c38:	80 1b       	sub	r24, r16
 c3a:	91 0b       	sbc	r25, r17
 c3c:	a2 0b       	sbc	r26, r18
 c3e:	b3 0b       	sbc	r27, r19
 c40:	f7 01       	movw	r30, r14
 c42:	03 81       	ldd	r16, Z+3	; 0x03
 c44:	14 81       	ldd	r17, Z+4	; 0x04
 c46:	25 81       	ldd	r18, Z+5	; 0x05
 c48:	36 81       	ldd	r19, Z+6	; 0x06
 c4a:	80 17       	cp	r24, r16
 c4c:	91 07       	cpc	r25, r17
 c4e:	a2 07       	cpc	r26, r18
 c50:	b3 07       	cpc	r27, r19
 c52:	e8 f2       	brcs	.-70     	; 0xc0e <_ZN8CFastLED4showEh+0x20>
 c54:	0e 94 9f 04 	call	0x93e	; 0x93e <micros>
 c58:	60 93 3f 01 	sts	0x013F, r22	; 0x80013f <_ZL8lastshow>
 c5c:	70 93 40 01 	sts	0x0140, r23	; 0x800140 <_ZL8lastshow+0x1>
 c60:	80 93 41 01 	sts	0x0141, r24	; 0x800141 <_ZL8lastshow+0x2>
 c64:	90 93 42 01 	sts	0x0142, r25	; 0x800142 <_ZL8lastshow+0x3>
 c68:	d7 01       	movw	r26, r14
 c6a:	1b 96       	adiw	r26, 0x0b	; 11
 c6c:	ed 91       	ld	r30, X+
 c6e:	fc 91       	ld	r31, X
 c70:	1c 97       	sbiw	r26, 0x0c	; 12
 c72:	30 97       	sbiw	r30, 0x00	; 0
 c74:	51 f0       	breq	.+20     	; 0xc8a <_ZN8CFastLED4showEh+0x9c>
 c76:	d7 01       	movw	r26, r14
 c78:	17 96       	adiw	r26, 0x07	; 7
 c7a:	4d 91       	ld	r20, X+
 c7c:	5d 91       	ld	r21, X+
 c7e:	6d 91       	ld	r22, X+
 c80:	7c 91       	ld	r23, X
 c82:	1a 97       	sbiw	r26, 0x0a	; 10
 c84:	8d 2d       	mov	r24, r13
 c86:	09 95       	icall
 c88:	d8 2e       	mov	r13, r24
 c8a:	00 91 45 01 	lds	r16, 0x0145	; 0x800145 <_ZN14CLEDController7m_pHeadE>
 c8e:	10 91 46 01 	lds	r17, 0x0146	; 0x800146 <_ZN14CLEDController7m_pHeadE+0x1>
 c92:	01 15       	cp	r16, r1
 c94:	11 05       	cpc	r17, r1
 c96:	79 f1       	breq	.+94     	; 0xcf6 <_ZN8CFastLED4showEh+0x108>
 c98:	f8 01       	movw	r30, r16
 c9a:	c4 84       	ldd	r12, Z+12	; 0x0c
 c9c:	d7 01       	movw	r26, r14
 c9e:	11 96       	adiw	r26, 0x01	; 1
 ca0:	8d 91       	ld	r24, X+
 ca2:	9c 91       	ld	r25, X
 ca4:	12 97       	sbiw	r26, 0x02	; 2
 ca6:	84 36       	cpi	r24, 0x64	; 100
 ca8:	91 05       	cpc	r25, r1
 caa:	08 f4       	brcc	.+2      	; 0xcae <_ZN8CFastLED4showEh+0xc0>
 cac:	14 86       	std	Z+12, r1	; 0x0c
 cae:	d8 01       	movw	r26, r16
 cb0:	ed 91       	ld	r30, X+
 cb2:	fc 91       	ld	r31, X
 cb4:	a2 80       	ldd	r10, Z+2	; 0x02
 cb6:	b3 80       	ldd	r11, Z+3	; 0x03
 cb8:	98 01       	movw	r18, r16
 cba:	27 5f       	subi	r18, 0xF7	; 247
 cbc:	3f 4f       	sbci	r19, 0xFF	; 255
 cbe:	a8 01       	movw	r20, r16
 cc0:	4a 5f       	subi	r20, 0xFA	; 250
 cc2:	5f 4f       	sbci	r21, 0xFF	; 255
 cc4:	6d 2d       	mov	r22, r13
 cc6:	ce 01       	movw	r24, r28
 cc8:	01 96       	adiw	r24, 0x01	; 1
 cca:	0e 94 3b 05 	call	0xa76	; 0xa76 <_ZN14CLEDController17computeAdjustmentEhRK4CRGBS2_>
 cce:	f8 01       	movw	r30, r16
 cd0:	45 85       	ldd	r20, Z+13	; 0x0d
 cd2:	56 85       	ldd	r21, Z+14	; 0x0e
 cd4:	62 81       	ldd	r22, Z+2	; 0x02
 cd6:	73 81       	ldd	r23, Z+3	; 0x03
 cd8:	9e 01       	movw	r18, r28
 cda:	2f 5f       	subi	r18, 0xFF	; 255
 cdc:	3f 4f       	sbci	r19, 0xFF	; 255
 cde:	c8 01       	movw	r24, r16
 ce0:	f5 01       	movw	r30, r10
 ce2:	09 95       	icall
 ce4:	d8 01       	movw	r26, r16
 ce6:	1c 96       	adiw	r26, 0x0c	; 12
 ce8:	cc 92       	st	X, r12
 cea:	1c 97       	sbiw	r26, 0x0c	; 12
 cec:	14 96       	adiw	r26, 0x04	; 4
 cee:	0d 91       	ld	r16, X+
 cf0:	1c 91       	ld	r17, X
 cf2:	15 97       	sbiw	r26, 0x05	; 5
 cf4:	ce cf       	rjmp	.-100    	; 0xc92 <_ZN8CFastLED4showEh+0xa4>
 cf6:	69 e1       	ldi	r22, 0x19	; 25
 cf8:	70 e0       	ldi	r23, 0x00	; 0
 cfa:	c7 01       	movw	r24, r14
 cfc:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN8CFastLED8countFPSEi>
 d00:	0f 90       	pop	r0
 d02:	0f 90       	pop	r0
 d04:	0f 90       	pop	r0
 d06:	df 91       	pop	r29
 d08:	cf 91       	pop	r28
 d0a:	1f 91       	pop	r17
 d0c:	0f 91       	pop	r16
 d0e:	ff 90       	pop	r15
 d10:	ef 90       	pop	r14
 d12:	df 90       	pop	r13
 d14:	cf 90       	pop	r12
 d16:	bf 90       	pop	r11
 d18:	af 90       	pop	r10
 d1a:	08 95       	ret

00000d1c <_ZN8CFastLED17setMaxRefreshRateEjb>:
 d1c:	cf 93       	push	r28
 d1e:	df 93       	push	r29
 d20:	ec 01       	movw	r28, r24
 d22:	44 23       	and	r20, r20
 d24:	e1 f0       	breq	.+56     	; 0xd5e <_ZN8CFastLED17setMaxRefreshRateEjb+0x42>
 d26:	61 15       	cp	r22, r1
 d28:	71 05       	cpc	r23, r1
 d2a:	71 f1       	breq	.+92     	; 0xd88 <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
 d2c:	9b 01       	movw	r18, r22
 d2e:	40 e0       	ldi	r20, 0x00	; 0
 d30:	50 e0       	ldi	r21, 0x00	; 0
 d32:	60 e4       	ldi	r22, 0x40	; 64
 d34:	72 e4       	ldi	r23, 0x42	; 66
 d36:	8f e0       	ldi	r24, 0x0F	; 15
 d38:	90 e0       	ldi	r25, 0x00	; 0
 d3a:	0e 94 50 07 	call	0xea0	; 0xea0 <__divmodsi4>
 d3e:	8b 81       	ldd	r24, Y+3	; 0x03
 d40:	9c 81       	ldd	r25, Y+4	; 0x04
 d42:	ad 81       	ldd	r26, Y+5	; 0x05
 d44:	be 81       	ldd	r27, Y+6	; 0x06
 d46:	82 17       	cp	r24, r18
 d48:	93 07       	cpc	r25, r19
 d4a:	a4 07       	cpc	r26, r20
 d4c:	b5 07       	cpc	r27, r21
 d4e:	10 f4       	brcc	.+4      	; 0xd54 <_ZN8CFastLED17setMaxRefreshRateEjb+0x38>
 d50:	da 01       	movw	r26, r20
 d52:	c9 01       	movw	r24, r18
 d54:	8b 83       	std	Y+3, r24	; 0x03
 d56:	9c 83       	std	Y+4, r25	; 0x04
 d58:	ad 83       	std	Y+5, r26	; 0x05
 d5a:	be 83       	std	Y+6, r27	; 0x06
 d5c:	15 c0       	rjmp	.+42     	; 0xd88 <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
 d5e:	61 15       	cp	r22, r1
 d60:	71 05       	cpc	r23, r1
 d62:	71 f0       	breq	.+28     	; 0xd80 <_ZN8CFastLED17setMaxRefreshRateEjb+0x64>
 d64:	9b 01       	movw	r18, r22
 d66:	40 e0       	ldi	r20, 0x00	; 0
 d68:	50 e0       	ldi	r21, 0x00	; 0
 d6a:	60 e4       	ldi	r22, 0x40	; 64
 d6c:	72 e4       	ldi	r23, 0x42	; 66
 d6e:	8f e0       	ldi	r24, 0x0F	; 15
 d70:	90 e0       	ldi	r25, 0x00	; 0
 d72:	0e 94 50 07 	call	0xea0	; 0xea0 <__divmodsi4>
 d76:	2b 83       	std	Y+3, r18	; 0x03
 d78:	3c 83       	std	Y+4, r19	; 0x04
 d7a:	4d 83       	std	Y+5, r20	; 0x05
 d7c:	5e 83       	std	Y+6, r21	; 0x06
 d7e:	04 c0       	rjmp	.+8      	; 0xd88 <_ZN8CFastLED17setMaxRefreshRateEjb+0x6c>
 d80:	1b 82       	std	Y+3, r1	; 0x03
 d82:	1c 82       	std	Y+4, r1	; 0x04
 d84:	1d 82       	std	Y+5, r1	; 0x05
 d86:	1e 82       	std	Y+6, r1	; 0x06
 d88:	df 91       	pop	r29
 d8a:	cf 91       	pop	r28
 d8c:	08 95       	ret

00000d8e <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii>:
 d8e:	cf 92       	push	r12
 d90:	df 92       	push	r13
 d92:	ef 92       	push	r14
 d94:	ff 92       	push	r15
 d96:	0f 93       	push	r16
 d98:	1f 93       	push	r17
 d9a:	cf 93       	push	r28
 d9c:	df 93       	push	r29
 d9e:	8c 01       	movw	r16, r24
 da0:	6b 01       	movw	r12, r22
 da2:	ea 01       	movw	r28, r20
 da4:	79 01       	movw	r14, r18
 da6:	12 16       	cp	r1, r18
 da8:	13 06       	cpc	r1, r19
 daa:	1c f0       	brlt	.+6      	; 0xdb2 <_ZN8CFastLED7addLedsEP14CLEDControllerP4CRGBii+0x24>
 dac:	7a 01       	movw	r14, r20
 dae:	c0 e0       	ldi	r28, 0x00	; 0
 db0:	d0 e0       	ldi	r29, 0x00	; 0
 db2:	d8 01       	movw	r26, r16
 db4:	ed 91       	ld	r30, X+
 db6:	fc 91       	ld	r31, X
 db8:	04 80       	ldd	r0, Z+4	; 0x04
 dba:	f5 81       	ldd	r31, Z+5	; 0x05
 dbc:	e0 2d       	mov	r30, r0
 dbe:	c8 01       	movw	r24, r16
 dc0:	09 95       	icall
 dc2:	ce 01       	movw	r24, r28
 dc4:	88 0f       	add	r24, r24
 dc6:	99 1f       	adc	r25, r25
 dc8:	c8 0f       	add	r28, r24
 dca:	d9 1f       	adc	r29, r25
 dcc:	cc 0d       	add	r28, r12
 dce:	dd 1d       	adc	r29, r13
 dd0:	f8 01       	movw	r30, r16
 dd2:	d3 83       	std	Z+3, r29	; 0x03
 dd4:	c2 83       	std	Z+2, r28	; 0x02
 dd6:	f6 86       	std	Z+14, r15	; 0x0e
 dd8:	e5 86       	std	Z+13, r14	; 0x0d
 dda:	01 90       	ld	r0, Z+
 ddc:	f0 81       	ld	r31, Z
 dde:	e0 2d       	mov	r30, r0
 de0:	02 84       	ldd	r0, Z+10	; 0x0a
 de2:	f3 85       	ldd	r31, Z+11	; 0x0b
 de4:	e0 2d       	mov	r30, r0
 de6:	c8 01       	movw	r24, r16
 de8:	09 95       	icall
 dea:	41 e0       	ldi	r20, 0x01	; 1
 dec:	bc 01       	movw	r22, r24
 dee:	87 e4       	ldi	r24, 0x47	; 71
 df0:	91 e0       	ldi	r25, 0x01	; 1
 df2:	0e 94 8e 06 	call	0xd1c	; 0xd1c <_ZN8CFastLED17setMaxRefreshRateEjb>
 df6:	c8 01       	movw	r24, r16
 df8:	df 91       	pop	r29
 dfa:	cf 91       	pop	r28
 dfc:	1f 91       	pop	r17
 dfe:	0f 91       	pop	r16
 e00:	ff 90       	pop	r15
 e02:	ef 90       	pop	r14
 e04:	df 90       	pop	r13
 e06:	cf 90       	pop	r12
 e08:	08 95       	ret

00000e0a <_GLOBAL__sub_I_pSmartMatrix>:

FASTLED_NAMESPACE_BEGIN

void *pSmartMatrix = NULL;

CFastLED FastLED;
 e0a:	87 e4       	ldi	r24, 0x47	; 71
 e0c:	91 e0       	ldi	r25, 0x01	; 1
 e0e:	0c 94 93 05 	jmp	0xb26	; 0xb26 <_ZN8CFastLEDC1Ev>

00000e12 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
 e12:	08 95       	ret

00000e14 <__mulsi3>:
 e14:	db 01       	movw	r26, r22
 e16:	8f 93       	push	r24
 e18:	9f 93       	push	r25
 e1a:	0e 94 76 07 	call	0xeec	; 0xeec <__muluhisi3>
 e1e:	bf 91       	pop	r27
 e20:	af 91       	pop	r26
 e22:	a2 9f       	mul	r26, r18
 e24:	80 0d       	add	r24, r0
 e26:	91 1d       	adc	r25, r1
 e28:	a3 9f       	mul	r26, r19
 e2a:	90 0d       	add	r25, r0
 e2c:	b2 9f       	mul	r27, r18
 e2e:	90 0d       	add	r25, r0
 e30:	11 24       	eor	r1, r1
 e32:	08 95       	ret

00000e34 <__divmodhi4>:
 e34:	97 fb       	bst	r25, 7
 e36:	07 2e       	mov	r0, r23
 e38:	16 f4       	brtc	.+4      	; 0xe3e <__divmodhi4+0xa>
 e3a:	00 94       	com	r0
 e3c:	07 d0       	rcall	.+14     	; 0xe4c <__divmodhi4_neg1>
 e3e:	77 fd       	sbrc	r23, 7
 e40:	09 d0       	rcall	.+18     	; 0xe54 <__divmodhi4_neg2>
 e42:	0e 94 81 07 	call	0xf02	; 0xf02 <__udivmodhi4>
 e46:	07 fc       	sbrc	r0, 7
 e48:	05 d0       	rcall	.+10     	; 0xe54 <__divmodhi4_neg2>
 e4a:	3e f4       	brtc	.+14     	; 0xe5a <__divmodhi4_exit>

00000e4c <__divmodhi4_neg1>:
 e4c:	90 95       	com	r25
 e4e:	81 95       	neg	r24
 e50:	9f 4f       	sbci	r25, 0xFF	; 255
 e52:	08 95       	ret

00000e54 <__divmodhi4_neg2>:
 e54:	70 95       	com	r23
 e56:	61 95       	neg	r22
 e58:	7f 4f       	sbci	r23, 0xFF	; 255

00000e5a <__divmodhi4_exit>:
 e5a:	08 95       	ret

00000e5c <__udivmodsi4>:
 e5c:	a1 e2       	ldi	r26, 0x21	; 33
 e5e:	1a 2e       	mov	r1, r26
 e60:	aa 1b       	sub	r26, r26
 e62:	bb 1b       	sub	r27, r27
 e64:	fd 01       	movw	r30, r26
 e66:	0d c0       	rjmp	.+26     	; 0xe82 <__udivmodsi4_ep>

00000e68 <__udivmodsi4_loop>:
 e68:	aa 1f       	adc	r26, r26
 e6a:	bb 1f       	adc	r27, r27
 e6c:	ee 1f       	adc	r30, r30
 e6e:	ff 1f       	adc	r31, r31
 e70:	a2 17       	cp	r26, r18
 e72:	b3 07       	cpc	r27, r19
 e74:	e4 07       	cpc	r30, r20
 e76:	f5 07       	cpc	r31, r21
 e78:	20 f0       	brcs	.+8      	; 0xe82 <__udivmodsi4_ep>
 e7a:	a2 1b       	sub	r26, r18
 e7c:	b3 0b       	sbc	r27, r19
 e7e:	e4 0b       	sbc	r30, r20
 e80:	f5 0b       	sbc	r31, r21

00000e82 <__udivmodsi4_ep>:
 e82:	66 1f       	adc	r22, r22
 e84:	77 1f       	adc	r23, r23
 e86:	88 1f       	adc	r24, r24
 e88:	99 1f       	adc	r25, r25
 e8a:	1a 94       	dec	r1
 e8c:	69 f7       	brne	.-38     	; 0xe68 <__udivmodsi4_loop>
 e8e:	60 95       	com	r22
 e90:	70 95       	com	r23
 e92:	80 95       	com	r24
 e94:	90 95       	com	r25
 e96:	9b 01       	movw	r18, r22
 e98:	ac 01       	movw	r20, r24
 e9a:	bd 01       	movw	r22, r26
 e9c:	cf 01       	movw	r24, r30
 e9e:	08 95       	ret

00000ea0 <__divmodsi4>:
 ea0:	05 2e       	mov	r0, r21
 ea2:	97 fb       	bst	r25, 7
 ea4:	1e f4       	brtc	.+6      	; 0xeac <__divmodsi4+0xc>
 ea6:	00 94       	com	r0
 ea8:	0e 94 67 07 	call	0xece	; 0xece <__negsi2>
 eac:	57 fd       	sbrc	r21, 7
 eae:	07 d0       	rcall	.+14     	; 0xebe <__divmodsi4_neg2>
 eb0:	0e 94 2e 07 	call	0xe5c	; 0xe5c <__udivmodsi4>
 eb4:	07 fc       	sbrc	r0, 7
 eb6:	03 d0       	rcall	.+6      	; 0xebe <__divmodsi4_neg2>
 eb8:	4e f4       	brtc	.+18     	; 0xecc <__divmodsi4_exit>
 eba:	0c 94 67 07 	jmp	0xece	; 0xece <__negsi2>

00000ebe <__divmodsi4_neg2>:
 ebe:	50 95       	com	r21
 ec0:	40 95       	com	r20
 ec2:	30 95       	com	r19
 ec4:	21 95       	neg	r18
 ec6:	3f 4f       	sbci	r19, 0xFF	; 255
 ec8:	4f 4f       	sbci	r20, 0xFF	; 255
 eca:	5f 4f       	sbci	r21, 0xFF	; 255

00000ecc <__divmodsi4_exit>:
 ecc:	08 95       	ret

00000ece <__negsi2>:
 ece:	90 95       	com	r25
 ed0:	80 95       	com	r24
 ed2:	70 95       	com	r23
 ed4:	61 95       	neg	r22
 ed6:	7f 4f       	sbci	r23, 0xFF	; 255
 ed8:	8f 4f       	sbci	r24, 0xFF	; 255
 eda:	9f 4f       	sbci	r25, 0xFF	; 255
 edc:	08 95       	ret

00000ede <__usmulhisi3>:
 ede:	0e 94 9b 07 	call	0xf36	; 0xf36 <__umulhisi3>

00000ee2 <__usmulhisi3_tail>:
 ee2:	b7 ff       	sbrs	r27, 7
 ee4:	08 95       	ret
 ee6:	82 1b       	sub	r24, r18
 ee8:	93 0b       	sbc	r25, r19
 eea:	08 95       	ret

00000eec <__muluhisi3>:
 eec:	0e 94 9b 07 	call	0xf36	; 0xf36 <__umulhisi3>
 ef0:	a5 9f       	mul	r26, r21
 ef2:	90 0d       	add	r25, r0
 ef4:	b4 9f       	mul	r27, r20
 ef6:	90 0d       	add	r25, r0
 ef8:	a4 9f       	mul	r26, r20
 efa:	80 0d       	add	r24, r0
 efc:	91 1d       	adc	r25, r1
 efe:	11 24       	eor	r1, r1
 f00:	08 95       	ret

00000f02 <__udivmodhi4>:
 f02:	aa 1b       	sub	r26, r26
 f04:	bb 1b       	sub	r27, r27
 f06:	51 e1       	ldi	r21, 0x11	; 17
 f08:	07 c0       	rjmp	.+14     	; 0xf18 <__udivmodhi4_ep>

00000f0a <__udivmodhi4_loop>:
 f0a:	aa 1f       	adc	r26, r26
 f0c:	bb 1f       	adc	r27, r27
 f0e:	a6 17       	cp	r26, r22
 f10:	b7 07       	cpc	r27, r23
 f12:	10 f0       	brcs	.+4      	; 0xf18 <__udivmodhi4_ep>
 f14:	a6 1b       	sub	r26, r22
 f16:	b7 0b       	sbc	r27, r23

00000f18 <__udivmodhi4_ep>:
 f18:	88 1f       	adc	r24, r24
 f1a:	99 1f       	adc	r25, r25
 f1c:	5a 95       	dec	r21
 f1e:	a9 f7       	brne	.-22     	; 0xf0a <__udivmodhi4_loop>
 f20:	80 95       	com	r24
 f22:	90 95       	com	r25
 f24:	bc 01       	movw	r22, r24
 f26:	cd 01       	movw	r24, r26
 f28:	08 95       	ret

00000f2a <__tablejump2__>:
 f2a:	ee 0f       	add	r30, r30
 f2c:	ff 1f       	adc	r31, r31
 f2e:	05 90       	lpm	r0, Z+
 f30:	f4 91       	lpm	r31, Z
 f32:	e0 2d       	mov	r30, r0
 f34:	09 94       	ijmp

00000f36 <__umulhisi3>:
 f36:	a2 9f       	mul	r26, r18
 f38:	b0 01       	movw	r22, r0
 f3a:	b3 9f       	mul	r27, r19
 f3c:	c0 01       	movw	r24, r0
 f3e:	a3 9f       	mul	r26, r19
 f40:	70 0d       	add	r23, r0
 f42:	81 1d       	adc	r24, r1
 f44:	11 24       	eor	r1, r1
 f46:	91 1d       	adc	r25, r1
 f48:	b2 9f       	mul	r27, r18
 f4a:	70 0d       	add	r23, r0
 f4c:	81 1d       	adc	r24, r1
 f4e:	11 24       	eor	r1, r1
 f50:	91 1d       	adc	r25, r1
 f52:	08 95       	ret

00000f54 <_exit>:
 f54:	f8 94       	cli

00000f56 <__stop_program>:
 f56:	ff cf       	rjmp	.-2      	; 0xf56 <__stop_program>
